# 2. 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 데이터를 찾는 2가지 방식 
1. 모든 교실을 돌며 홍길동을 찾는 방식(Table Full Scan)
2. 학생 명부를 조회해 홍길동이 있는 교실만 찾아가는 방식(Index Range Scan)

#### 인덱스란?
- 큰 테이블에서 소량 데이터를 검색할 때 사용하는 방법(온라인 트랜잭션 처리, OLTP에서 주로 사용)

#### 인텍스 튜닝하는 2가지 방법 
1. 인덱스 스캔 효율화 튜닝
    - 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
2. 랜덤 액세스 최소화 튜닝
    - 테이블 액세스 횟수를 줄이는 것
    - 성능에 미치는 영향이 더 큼
    - 인덱스 튜닝은 랜덤 I/O와의 전쟁이라고 할 수 있음
		- 명부에서 이름을 찾는 것이 '인덱스 스캔'이라면,
		- 명부에서 찾은 이름의 학생의 반교실을 찾아가는 과정이 '랜덤 I/O'이다.
		- 명부상에서는 이름이 붙어 있어도(김철수, 김영희), 김철수는 1층 1반에 있고 김영희는 5층 10반에 있을 수 있음 
		- 1반 갔다가, 갑자기 10반 갔다가, 다시 3반으로 뛰어가는 과정에서 복도를 걷고 계단을 오르내리는 시간(디스크 헤드가 움직이는 시간)이 많이 걸리기 때문에 성능에 가장 큰 영향을 줍니다.

### 2.1.2 인덱스 구조

#### B*Tree 인덱스

![image](https://github.com/user-attachments/assets/f19bdf40-54fb-444d-906c-a5521c8a2335)

- DBMS는 보통 B*Tree 인덱스를 사용한다. 
	- 맨 위에 Root
	- 중간에 Branch
	- 맨 아래 Leaf

- Root와 Branch의 키값은 하위 블록에 대한 주소값을 갖는다. 
- 하지만 LMC(Leftmost Child)은 키값을 갖지 않는다. 
	- LMC에는 키값을 가진 첫 번째 레코드가 저장되어 있음

#### LMC(Leftmost Child)란?

> LMC는 탐색하려는 값이 해당 블록의 그 어떤 기준점(Key)보다도 작을 때 선택되는 '0순위 통로'입니다. 이 덕분에 DBMS는 어떤 값이 들어오든 막힘없이 하위 노드로 내려갈 길을 찾을 수 있습니다.

![image](https://github.com/user-attachments/assets/dee48696-8f70-44ed-bd80-a0ae0908be42)

- 브랜치 블록을 보면, 맨 왼쪽 칸만 키값이 비어 있다. 
- LMC는 B*Tree 인덱스의 브랜치(Branch)나 루트(Root) 블록에서 **"가장 왼쪽에 위치한 자식 노드를 가리키는 특별한 포인터"** 이다.

- 쉬운 비유
	- 도서관의 안내 표지판을 떠올려 보세요.
	- `[ (LMC) | 100번대 | 200번대 ]`
		- 200번대 : 200번부터 그 이상 책들 (주소 3번으로 가세요)
		- 100번대 : 100번부터 199번까지 책들 (주소 2번으로 가세요)
		- LMC : (그냥 맨 앞에 위치) "100번보다 작은 모든 책" (주소 1번으로 가세요)
		- 여기서 LMC는 굳이 "0~99번"이라고 적혀 있지 않아도, 100번보다 작은 책들을 찾는 사람들을 위해 존재하는 길잡이와 같습니다.

- LMC의 특징
	- 키값이 없다
		- LMC는 특정 값과 짝을 이루지 않습니다. 
		- 그저 "이 블록의 최소 키값보다 작은 모든 것"을 담당하기 때문입니다.
	- 블록의 첫 번째 포인터(= 모든 인덱스 블록(리프 제외)의가장 왼쪽 = 맨 처음)에 위치합니다.
	- "최솟값"을 굳이 키로 저장하지 않아도 되므로 공간 저장에 있어 효율적입니다.

- 왜 LMC라는 별도의 이름이 있을까?
	- 보통 인덱스 블록은 [키값 | 자식 주소] 쌍으로 저장됩니다. 
	- 하지만 이렇게만 구성하면 **"첫 번째 키값보다 작은 데이터"** 를 어디서 찾아야 할지 알 수 없게 됩니다.
	- 예를 들어, 블록에 키값 **[20, 50]** 이 들어있다고 가정해 봅시다.
		- 50 이상은 '50' 옆에 있는 포인터를 따라가면 됩니다.
		- 20 이상 50 미만은 '20' 옆에 있는 포인터를 따라가면 됩니다.
		- 그런데 20 미만은 어디로 가야 할까요?
		- 이때 바로 맨 앞에 있는 LMC(Leftmost Child) 포인터가 **"20보다 작은 애들은 이 주소로 가!"** 라고 안내해 주는 것입니다.


#### LMC가 실제 Index Range Scan 과정에서 어떻게 처음 경로를 결정할까?

- 실제 Index Range Scan이 시작될 때, DBMS가 LMC를 활용하여 길을 찾는 과정은 마치 **"조건문(if-else)"** 을 통과하는 것과 비슷합니다.
- LMC가 처음 경로를 결정하는 단계
	- 예를 들어, `SELECT * FROM 사원 WHERE 사번 = 5;` 라는 쿼리를 실행했다고 가정해 봅시다.
	- 루트 블록(Root Block)에는 다음과 같은 정보가 들어있습니다.
		- LMC : 주소 A
		- Key 10 : 주소 B
		- Key 20 : 주소 C
	- 이때 DBMS는 찾으려는 값(5)을 가지고 왼쪽에서 오른쪽으로 키값을 비교합니다.
		- 첫 번째 키값(10)과 비교 : `"내가 찾는 5가 10보다 작은가?"`
		- 결과 : `YES`
			- 찾으려는 값 5는 10보다 작으므로, 10의 오른쪽에 있는 주소 B로 갈 필요가 없습니다.
		- 결정 : `LMC(주소 A)`를 타고 내려감
			- 10보다 왼쪽에 있는 유일한 통로인 **LMC(주소 A)** 를 타고 내려갑니다.

	- 만약 찾는 값이 15라면?
		- 첫 번째 키(10)와 비교 : `"15가 10보다 작은가?"` → `NO` (오른쪽으로 이동)
		- 두 번째 키(20)와 비교 : `"15가 20보다 작은가?"` → `YES`
		- 결정: `10과 20 사이의 포인터` 를 타고 내려갑니다.

- 만약 LMC가 없다면, 모든 포인터는 반드시 키값과 짝을 이뤄야 합니다.
	- 그렇게 되면 **"데이터의 최솟값"** 이 바뀔 때마다 루트나 브랜치에 있는 키값도 계속 수정해야 하는 번거로움이 생깁니다.
	- 하지만 LMC라는 "그냥 제일 왼쪽 통로"를 하나 뚫어 놓음으로써, 아무리 작은 데이터가 들어와도 인덱스 상위 노드들을 수정할 필요 없이 **"무조건 왼쪽 끝으로 가"** 라고 안내할 수 있게 된 것입니다.

- LMC를 타고 리프 블록까지 내려가면, 거기서부터는 **리프 노드 간의 수평적 연결(Double Linked List)** 을 이용합니다.
	- 수직적 탐색: LMC 등을 이용해 시작점인 리프 블록을 찾음.
 	- 수평적 탐색: 시작 리프 블록부터 옆으로 쭉 읽어나가며 조건에 맞는 데이터를 다 긁어모음.

#### 인덱스를 스캔하는 이유 
- 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서임
- `ROWID` = `데이터 블록주소(DBA, Data Block Address)` + `로우번호`
    - `데이터 블록 주소(DBA)` = `데이터 파일 번호` + `블록 번호`
        - `블록번호` : 데이터 파일 내에서 부여한 상대적 순번
        - `로우번호` : 블록 내 순번

### 2.1.3 인덱스 수직적 탐색

- 인덱스 스캔 시작지점을 찾는 과정이다. 
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이라고 볼 수 있음
- 수직적 탐색은 Root부터 시작해서, 찾고자 하는 값보다 크거나 같은(`>=`) 값을 만나면 직전 레코드가 가리키는 하위 블록으로 이동한다. 

- '크거나 같은(>=)' vs '큰(>)' 탐색의 차이
	- 수직적 탐색 시 **'직전 레코드로 이동'** 하는 로직은 동일하지만, 
	- 리프 노드에 도착했을 때 **'어디서부터 읽기 시작할지'** 가 달라집니다.
		- `>= 15` 조건
			- 리프 노드에 도착해서 15가 있는지 찾습니다.
			- 15가 있다면 15가 처음 나타나는 지점부터 오른쪽으로 읽기 시작합니다.
		- `> 15` 조건
			- 리프 노드에 도착해서 15를 찾습니다.
			- 15가 있어도 무시하고, 15보다 큰 값이 처음 나타나는 지점부터 읽기 시작합니다.

	- 인덱스에서는 `>`와 `>=`의 성능 차이가 거의 없습니다. 
		- 수직적 탐색으로 시작점을 찾는 비용은 똑같고, 
		- 리프 노드에서 한두 건 더 보느냐 마느냐의 차이일 뿐이기 때문입니다.

### 2.1.4 인덱스 수평적 탐색

- 인덱스에서 본격적으로 데이터를 찾는 과정이다. 
- Leaf 블록은 서로의 앞뒤 블록에 대한 주소값을 갖는다. 
- 인덱스를 수평적으로 탐색하는 이유는?
    1. 조건절을 만족하는 데이터를 모두 찾기 위해서
    2. 테이블 액서스하기 위한 ROWID를 얻기 위해서

### 2.1.5 결합 인덱스 구조와 탐색

- [이름+성별] 인덱스나 [성별+이름] 인덱스나 읽는 인덱스 블록 개수는 똑같다. 
- DBMS가 사용하는 B*Tree 인덱스가 평면 구조가 아니기 때문이다. 
- Delete 작업이 일어나도 B*Tree 인덱스에서는 인덱스 루트에서 리프 블록까지 도달하기 위해 읽는 블록 수는 같다. 