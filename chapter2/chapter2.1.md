# 2. 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

- 데이터를 찾는 2가지 방식 
    1. 모든 교실을 돌며 홍길동을 찾는 방식(Table Full Scan)
    2. 학생 명부를 조회해 홍길동이 있는 교실만 찾아가는 방식(Index Range Scan)

- 인덱스란?
    - 큰 테이블에서 소량 데이터를 검색할 때 사용하는 방법(온라인 트랜잭션 처리, OLTP에서 주로 사용)

- 인텍스 튜닝하는 2가지 방법 
    1. 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
    2. 랜덤 액세스 최소화 튜닝
        - 테이블 액세스 횟수를 줄이는 것
        - 성능에 미치는 영향이 더 큼
        - 인덱스 튜닝은 랜덤 I/O와의 전쟁이라고 할 수 있음

### 2.1.2 인덱스 구조

DBMS는 보통 B*Tree 인덱스를 사용한다. 
- 맨 위에 Root
- 중간에 Branch
- 맨 아래 Leaf

Root와 Branch의 키값은 하위 블록에 대한 주소값을 갖는다. 하지만 LMC(Leftmost Child)은 키값을 갖지 않는다. 
- LMC에는 키값을 가진 첫 번째 레코드가 저장되어 있음

인덱스를 스캔하는 이유 
    - 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서임
    - ROWID = 데이터 블록주소(DBA, Data Block Address) + ROW 번호
        - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
            - 블록번호 : 데이터 파일 내에서 부여한 상대적 순번
            - 로우번호 : 블록 내 순번

### 2.1.3 인덱스 수직적 탐색

- 인덱스 스캔 시작지점을 찾는 과정이다. 
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이라고 볼 수 있음
- 수직적 탐색은 Root부터 시작해서, 찾고자 하는 값보다 크거나 같은 값을 만나면 직전 레코드가 가리키는 하위 블록으로 이동한다. 

### 2.1.4 인덱스 수평적 탐색

- 인덱스에서 본격적으로 데이터를 찾는 과정이다. 
- Leaf 블록은 서로의 앞뒤 블록에 대한 주소값을 갖는다. 
- 인덱스를 수평적으로 탐색하는 이유는?
    1. 조건절을 만족하는 데이터를 모두 찾기 위해서
    2. 테이블 액서스하기 위한 ROWID를 얻기 위해서

### 2.1.5 결합 인덱스 구조와 탐색

- [이름+성별] 인덱스나 [성별+이름] 인덱스나 읽는 인덱스 블록 개수는 똑같다. 
- DBMS가 사용하는 B*Tree 인덱스가 평면 구조가 아니기 때문이다. 
- Delete 작업이 일어나도 B*Tree 인덱스에서는 인덱스 루트에서 리프 블록까지 도달하기 위해 읽는 블록 수는 같다. 