# 2. 인덱스 기본

## 2.3 인덱스 확장기능 사용법

### 2.3.1 Index Range Scan

- B*Tree 인덱스의 가장 일반적인 형태임
- 인덱스 루트에서 리프 블록까지 수직적으로 탐색 후, 필요한 범위만 스캔하는 방식이다. 
- 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 한다!
- 실행계획 : `INDEX (RANGE SCAN)`

### 2.3.2 Index Full Scan

- 수직적 탐색을 하지 않고, 인덱스 리프블록을 처음~끝까지 수평적 탐색하는 방식이다. 
- 최적의 인덱스가 없을 때, 차선으로 선택된다. 
- 실행계획 : `INDEX (FULL SCAN)`

#### Table Full Scan
- 책의 첫 페이지부터 끝까지 쭉 훑는 방식입니다. 
- 한 번에 여러 페이지(Multi-block Read)를 집어서 읽기 때문에 속도가 빠릅니다.

#### Index Full Scan 후 테이블 액세스
- 인덱스라는 '색인'을 한 칸씩 읽으면서, 그 안에 적힌 주소를 보고 
- **매번 테이블로 점프(Single-block Read)** 해서 데이터를 가져옵니다.
- 만약 읽어야 할 데이터가 100만 건인데 인덱스를 통해 테이블을 100만 번 점프해서 읽는다면?
- 그냥 테이블 처음부터 끝까지 쭉 읽는 것보다 훨씬 느려집니다.


#### 대용량 테이블의 경우
- 테이블이 차지하는 데이터 저장공간보다 인덱스가 차지하는 면적이 훨씬 적기 때문에...
- 옵티마이저가 `Table Full Scan` 대신 `Index Full Scan` 을 사용한다. 
- 하지만 이는 적절한 인덱스가 없어 `INDEX FULL SCAN`을 선택한 것뿐이므로...
- 수행빈도가 높다면? 
	- 적절한 인덱스를 생성해 주는 것이 좋다.

#### first_rows 옵션
- 소트 연산 생략을 위해 옵티마이저가 전략적으로 선택하는 경우도 있다.
- 인덱스를 Full Scan 하면 결과집합이 인덱스 컬럼 순으로 정렬된다. 
	- 따라서 Sort Order By 연산을 생략하기 위한 용도로 인덱스를 사용할 수 있다. 

- 하지만 그 범위가 많아서 거의 모든 테이블에 액세스가 발생한다면, Table Full Scan 보다 비효율적일 수 있다. 

- `/*+ first_rows */` 힌트를 쓰면 전체 집합 중 처음 일부를 빠르게 출력할 목적으로 옵티마이저가 Index Full Scan 방식을 선택하기도 한다. 
	- 이는 부분범위 처리가 가능한 상황일 때는 극적인 개선효과를 주지만 fetch를 멈추지 않고 끝까지 데이터를 읽는다면 Table Full Scan보다 비효율적이게 된다. 

### 2.3.3 Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식이다. 
- `=`으로 검색할 때만 적용된다. 
- Unique 인덱스가 존재하는 컬럼은 중복값이 입력되지 않게 DBMS가 데이터 정합성을 관리해준다.
	- 따라서, 인덱스 키 컬럼을 모두 `=`으로 검색한다면 데이터를 딱 한 건 찾고 끝난다.
- 실행계획 : `INDES (UNIQUE SCAN)`


#### Index Unique Scan이 아닌 Index Range Scan으로 검색되는 경우
1. Unique인덱스를 범위검색 조건(between, LIKE, >=...) 으로 검색한다면?
	- Index Range Scan으로 처리된다.
	- 수직적 탐색만으로는 조건에 해당하는 레코드를 전부 찾을 수 없기 때문이다.

2. Unique 결합 인덱스의 일부 컬럼만 가지고 검색한다면?
	- 이때도 Index Range Scan으로 처리된다.
	-	Unique 인덱스라 하더라도, 결합인덱스에 쓰인 컬럼이 모두 조합되었을 때만 중복되지 않는 Unique한 값이 되는 것이다.
	- 따라서 일부 컬럼만 쓰면 중복된 값이 나올 가능성이 생기기 때문에, 오라클은 안전하게 '범위를 훑는(Range Scan)' 방식을 택한다.

### 2.3.4 Index Skip Scan

> 오라클 9i부터 새로 생긴 스캔 방식이다. 하지만 피치못할 상황일 때 차선책으로 활용하는 것이 적합하다.

- 루트 또는 브랜치 블록에서 읽은 값 정보를 이용해서, **조건절에 부합하는 레코드를 포함할 '가능성이 있는' 리프블록** 만 골라서 액세스하는 스캔방식이다. 
- 선두 컬럼이 조건절에 없어도, 후행 컬럼의 Distinct Value가 많을 때 유용함
	- 예) 고객테이블에서 Distinct Value가 가장 적은 컬럼은 '성별'이다. 
		- 남/녀 외에 다른 Value가 없기 때문이다. 
		- Distinct Value는 중복값을 의미하는 것이 아님!

- 실행계획 : `INDEX(SKIP SCAN)`
- 힌트 
	1. 인덱스 스킵 스캔 방식을 유도할 때는?
		- `index_ss` 힌트를 사용한다.
		- `/*+ index_ss(사원 사원_IDX) */`

	2. 인덱스 스킵 스캔 방식을 방지할 때는?
		- `no_index_ss` 힌트를 사용한다.
		- `/*+ no_index_ss(사원 사원_IDX) */`

#### (예시) 선두 컬럼이 '범위' 조건일 때

```
일별업종별거래_X01 : 기준일자 + 업종유형코드
```

```sql
SELECT /*+ INDEX_SS(A 일별업종별거래_X01) */
		기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM 일별업종거래 A
WHERE 기준일자 BETWEEN '20080501' AND '20080531'
AND 업종유형코드 = '01'
```

- 조건 : 기준일자가 5월 한 달간(BETWEEN)이고, 업종유형코드가 '01'인 것.

- 작동 원리
	1. Index Range Scan
		- 5월 1일부터 5월 31일까지의 모든 인덱스 데이터를 다 읽어야 합니다.
	2. Index Skip Scan
		- 5월 1일 중 '01'인 것 찾고 → 바로 5월 2일의 '01'로 점프 → 5월 3일의 '01'로 점프... 
		- 이런 식으로 '01'이 들어있을 가능성이 있는 리프 블록만 골라서 액세스합니다. 훨씬 빠르겠죠?

#### (예시) 중간 컬럼이 빠졌을 때

```
일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
```

```sql
SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
		기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM 일별업종거래 A
WHERE 업종유형코드 = '01'
AND 기준일자 BETWEEN '20080501' AND '20080531'
```

- 조건 : 업종유형코드는 있는데, 중간에 있는 업종코드 조건이 없을 때
	- 인덱스는 세 컬럼이 결합되어 있어 중간이 비면 원래 효율적으로 쓰기 어렵습니다. 
	- 하지만 Skip Scan을 쓰면, 업종코드의 종류(Distinct Value)가 적을 경우 각 코드별로 "스킵"하며 기준일자를 찾아냅니다.

- 작동 원리
	1. Index Range Scan
		- 업종유형코드 = '01'인 인덱스 구간 데이터를 모두 읽어야 합니다.
	2. Index Skip Scan
		- 업종유형코드 = '01' 중 '20080501'보다 크거나 같도 '20080531'보다 작거나 같은 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스한다. 

#### (예시) Distinct Value가 적은 두 개의 선두컬럼이 조건절에 없는 경우

```
일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
```

```sql
SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
		기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM 일별업종거래 A
WHERE 기준일자 BETWEEN '20080501' AND '20080531'
```

- 선두컬럼이 모두 조건절에 없는 경우에도 Index Skip Scan을 유용하게 사용할 수 있다.


### 2.3.5 Index Fast Full Scan

- Index Full Scan보다 빠른 이유는?
	- 논리적 인덱스 트리 구조를 무시하고, Multiblock I/O 방식으로 세그먼트 전체를 스캔하기 때문이다.

- Multiblock I/O 방식 사용 
	- 일반적인 Full Scan은 인덱스의 논리적 구조(정렬 순서)를 따라 한 블록씩 읽지만,
	- Fast Full Scan은 물리적으로 연결된 여러 블록을 한꺼번에 뭉텅이로 읽어옵니다.
	- 인덱스의 특정 부분만 읽는 것이 아니라 전체를 다 읽습니다.

- 논리적 트리 무시
	- 인덱스는 원래 Root → Branch → Leaf 블록 순서로 연결되어 있지만, 
	- IFFS는 이 구조를 무시하고 인덱스 세그먼트 전체를 물리적으로 그냥 긁어버립니다.

- 속도는 빠르지만, 인덱스 키 순서대로 정렬되지 않는다. 
	- 물리적으로 블록을 읽어오기 때문에, 인덱스 키 순서대로 데이터가 나오지 않습니다. 
	- 만약 ORDER BY가 필요하다면 별도의 정렬 작업이 추가로 발생할 수 있습니다.

- 쿼리에 사용될 컬럼이 모두 인덱스에 포함돼 있을 때만 사용할 수 있다.
	- 테이블에 직접 찾아갈 필요가 없을 때만 이 방식을 쓸 수 있습니다.

- 인덱스가 파티션 돼 있지 않더라도 병렬쿼리가 가능하다. 
	- Index Range Scan 또는 Index Full Scan은 파티션 되어 있어야 병렬처리가 가능하다.
	- 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빠르다
		- 병렬로 읽을 때는 DB 버퍼 캐시를 거치지 않고 디스크에서 바로 읽어오는 Direct Path I/O 방식을 사용하므로 속도가 극대화됩니다.


#### 🔍 이해를 돕는 비교 테이블
| 구분 | Index Full Scan | Index Fast Full Scan |
|---|---|---|
| I/O 방식 | Single Block I/O | Multiblock I/O |
| 정렬 상태 | 인덱스 키 순서로 정렬됨 | 정렬 보장 안 됨 |
| 병렬 처리 | 파티션 되어야 가능 | 파티션 없어도 가능 |
| 사용 조건 | - | 모든 컬럼이 인덱스에 포함 |


### 2.3.6 Index Range Scan Descending

- Index Range Scan 과 동일하지만, 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다는 점만 다르다.

- 보통 order by empno desc 가 있으면 옵티마저가 자동으로 인덱스를 거꾸로 읽는다. 
- 만약 동작하지 않는다면, `index_desc` 힌트를 사용해서 유도할 수 있다. 

- MAX값을 구할 때에도, 자동으로 인덱스를 뒤에서부터 읽고 멈추는 실행계획이 동작한다.  
