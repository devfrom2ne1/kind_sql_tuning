# 2. 인덱스 기본

## 2.3 인덱스 확장기능 사용법

### 2.3.1 Index Range Scan

- B*Tree 인덱스의 가장 일반적인 형태임
- 인덱스 루트에서 리프 블록까지 수직적으로 탐색 후, 필요한 범위만 스캔하는 방식이다. 
- 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 한다!

### 2.3.2 Index Full Scan

- 수직적 탐색을 하지 않고, 인덱스 리프블록을 처음~끝까지 수평적 탐색하는 방식이다. 
- 최적의 인덱스가 없을 때, 차선으로 선택된다. 

#### Index Full Scan을 선택하는 케이스
- 테이블이 차지하는 데이터 저장공간보다 인덱스가 차지하는 면적이 훨씬 적기 때문에, 옵티마이저가 Table Full Scan 대신 Index Full Scan을 사용한다. 

#### 소트 연산 생략

- 인덱스를 Full Scan 하면 결과집합이 인덱스 컬럼 순으로 정렬된다. 
- 따라서 Sort Order By 연산을 생략하기 위한 용도로 인덱스를 사용할 수 있다. 
- 옵티마이저가 SQL에 작성된 order by 대신 Index를 취하기도 한다. 

### 2.3.3 Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식이다. 
- `=`으로 검색할 때만 적용된다. 

### 2.3.4 Index Skip Scan

- 오라클 9i부터 새로 생긴 스캔 방식임
- 선두 컬럼이 조건절에 없어도, 후행 컬럼의 Distinct Value가 많을 때 유용함
    - 예) 고객테이블에서 Distinct Value가 가장 적은 컬럼은 '성별'이다. 
        - 남/녀 외에 다른 Value가 없기 때문이다. 
        - Distinct Value는 중복값을 의미하는 것이 아님!

**(참고) 친절한 SQL튜닝 : 117페이지**

- Inedex Skip Scan이 작동하는 경우
    1) 인덱스 = 성별 + 연봉 
        - '연봉' 범위조건으로만 조회할 경우
    2) 인덱스 = 업종유형코드 + 업종코드 + 기준일자
        - '업종유형코드' + '기준일자'로만 조회하는 경우
        - '기준일자'로만 조회하는 경우
        - '기준일자'(범위검색) + '업종유형코드'로만 조회하는 경우

### 2.3.5 Index Fast Full Scan

- Index Full Scan보다 빠른 이유는?
    - 논리적 인덱스 트리 구조를 무시하고, Multiblock I/O 방식으로 스캔하기 때문임
- 세그먼트 전체를 스캔한다. 
- 속도는 빠르지만, 인덱스 키 순서대로 정렬되지 않는다. 
- 쿼리에 사용될 컬럼이 모두 인덱스에 포함돼 있을 때만 사용할 수 있다.
- 인덱스가 파티션 돼 있지 않더라도 병렬쿼리가 가능하다. 
    - 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빠르다

### 2.3.6 Index Range Scan Descending

- Index Range Scan 과 동일하지만, 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다는 점만 다르다.

- 보통 order by empno desc 가 있으면 옵티마저가 자동으로 인덱스를 거꾸로 읽는다. 
- 만약 동작하지 않는다면, `index_desc` 힌트를 사용해서 유도할 수 있다. 

- MAX값을 구할 때에도, 자동으로 인덱스를 뒤에서부터 읽고 멈추는 실행계획이 동작한다.  
