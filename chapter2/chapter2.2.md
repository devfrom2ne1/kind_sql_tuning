# 2. 인덱스 기본

## 2.2 인덱스 기본 사용법

### 2.2.1 인덱스를 사용한다는 것

#### Index Range Scan
- 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 
- 즉, 리프 블록의 **"일부"** 만 스캔하는 것이다.
- Index Range Scan에선 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 
- 인덱스 스캔 시작점을 찾을 수 없게 되기 때문이다.

#### Index Full Scan 
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있다. 
- 하지만 스캔 시작점을 찾을 수 없고, 멈출 수도 없어서 **"블록 전체"** 를 스캔해야한다.
- 즉, 일부가 아닌 전체를 스캔하는 방식이 Index Full Scan 방식이다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유

- 인덱스 컬럼을 가공하면, 인덱스 스캔 시작점을 찾을 수 없기 때문에 인덱스를 정상적으로 사용할 수 없다.
- Index Range Scan을 하려면 스캔의 `시작지점` 과 `종료지점`이 있어야 한다.	
	- `시작지점` 을 찾는 행위는 "수직적 탐색"과 같다.

#### between 조건절

```sql
where birth_dt between '20070101' and '20070131'
```

- 예를 들어, 생년월일 순으로 학생을 줄세웠다고 생각해보자.
- 이때 2007년 1월 생을 찾는다면, 2007년 1월 1일에 태어난 학생부터 시작해서 2007년 2월 1일에 태어난 학생 전까지 탐색하면 된다. 

#### substr 조건절

```sql
where substr(birth_dt, 5, 2) = '05'
```

- 하지만, 년도에 관계없이 5월생을 찾는다면?
- 이렇게 되면 시작점을 잡을 수가 없어서, 인덱스를 Range Scan 할 수 없게 된다. 

#### LIKE 조건절

```sql
where 업체명 like '대한%'
```

- 특정 문자열로 시작하는 단어는 특정 구간에 모여있어서 Range Scan이 가능하다.


```sql
where 업체명 like '%대한%'
```

- 하지만, 중간에 있는 값들은 전 구간에 걸쳐있어서 Range Scan을 할 수 없다.

#### NVL 조건절

```sql
WHERE NVL(주문수량, 0) < 100
```

- '값이 NULL이면 0으로 치환한 값' 기준으로 100보다 작은 레코드를 찾는 쿼리이다.
- 그렇다면 시작지점을 찾기 어려워진다.. 왜?
	- 오라클에서 인덱스는 '가나다순'으로 정리된 단어장과 같습니다. 
	- NULL은 '내용 없음'이 아니라, **'가장 큰 값(무한대)'** 으로 취급해서 단어장의 맨 뒷장에 몰아넣는다고 생각하면 쉽습니다.

- 오라클의 기본 원칙은 **"NULL은 무한대"** 입니다.
	- `오름차순 인덱스`
		-	`1, 2, 3...` 순서로 기록하다가 맨 마지막 리프 블록에 NULL을 모아둡니다.
		- 그래서 "100보다 큰 값을 찾아라" 할 때 NULL까지 같이 딸려 나오기 쉽습니다.

	- `내림차순 인덱스`
		- 반대로 NULL이 가장 크니까 맨 첫 번째 리프 블록에 NULL이 먼저 나옵니다.

- `WHERE 주문수량 < 100` 이라고 하면? 
	- 오라클은 단어장의 첫 페이지부터 100이 나오기 전까지만 슥 읽고 끝내면 됩니다.

- 하지만, `WHERE NVL(주문수량, 0) < 100`이라면? 
	- "맨 뒷장에 있던 애들이 갑자기 맨 앞(0의 위치)으로 와야 합니다!

- 실제 인덱스 종이에는 여전히 NULL이 맨 뒤에 적혀 있습니다.
	- 오라클은 "인덱스에 적힌 순서랑 내가 계산한 순서가 안 맞네? 그럼 인덱스(단어장) 안 쓰고 그냥 처음부터 끝까지 다 읽을래" 하고 포기해 버립니다.
	- 이걸 전문 용어로 **"인덱스를 타지 못한다(Full Table Scan)"** 라고 합니다.

- (예외) **"단일 컬럼"**
	- 만약 인덱스를 주문수량 하나에만 걸어두면, 오라클은 값이 NULL인 행은 아예 인덱스에 저장조차 안 합니다.
	- 즉, 단어장에 아예 존재하지도 않으니 WHERE 주문수량 IS NULL이라고 검색해도 인덱스를 못 쓰고 전체를 다 뒤져야 하는 거죠.

- 즉, 오라클에서 NULL은 기본적으로 **맨 뒤(가장 큰 값)** 에 있기 때문에...
	- NVL을 쓰는 순간, 맨 뒤에 있어야 할 NULL이 맨 앞(0)으로 가야 하는 모순이 생겨서 인덱스 순서가 꼬입니다.

- 성능을 높이려면 NVL 대신 인덱스를 그대로 쓸 수 있는 조건을 사용하는 게 좋습니다.

#### (참고) 다른 주요 데이터베이스(SQL Server, MySQL, PostgreSQL)에서의 `NULL`
> 어떤 DB를 쓰든 조건절(WHERE)에 이런 함수(NVL, ISNULL 등)를 입히는 순간, DB는 인덱스 리프 블록의 "정해진 시작점"을 찾지 못하고 헤매게 됩니다.

1. SQL Server & MySQL : "NULL은 꼴등(마이너스 무한대)"
	- 이 두 DB는 NULL을 `가장 작은 값` 이라고 생각합니다.
	- 숫자 : `NULL → -9999... → 1 → 2`
	- 문자 : `NULL → A → B → Z`
	- 날짜 : `NULL → 1900년 → 2024년`
	- 인덱스 위치 : 오름차순(ASC) 기준, 리프 블록의 **맨 앞(First)** 에 차곡차곡 쌓입니다.

2. PostgreSQL : "NULL은 무한대(가장 큰 값)"
	- PostgreSQL은 오라클과 비슷하게 NULL을 가장 큰 값으로 취급합니다.
	- 인덱스 위치: 오름차순(ASC) 기준, 리프 블록의 **맨 뒤(Last)** 에 저장됩니다.

3. 함수 이름의 차이 (오라클 NVL)
> 꿀팁: COALESCE는 거의 모든 DB에서 공통으로 쓸 수 있는 표준 문법이라 실무에서 가장 권장됩니다.

| DB 종류 | 함수명 | 사용 예시 |
|---|---|---|
| Oracle | NVL | NVL(컬럼, 0) |
| SQL Server | ISNULL | ISNULL(컬럼, 0) |
| MySQL | IFNULL | IFNULL(컬럼, 0) |
| 표준 SQL (공통) | COALESCE | COALESCE(컬럼, 0) |

#### OR 조건절

```sql
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```

- 수직적 방식으로 시작점을 찾을 수 없고, 어떤 방식으로 인덱스를 구성해도 Range Scan이 불가능하다.

```sql
select * 
from 고객
where 고객명 = :cust_nm
union all
select * 
from 고객
where 전화번호 = :tel_no
and (고객명 <> :cust_nm or 고객명 is null)
```

- 하지만 이렇게 옵티마이저가 `OR Expansion` 형태로 변환할 수 있다. 
- 이 때는 Index Range Scan이 발동했다. 

#### IN 조건절

```sql
/* 사원번호 10, 20, 30번을 찾는 IN-List 쿼리*/
SELECT * FROM 사원 
WHERE 사원번호 IN (10, 20, 30);
```

- IN은 OR나 같다. 
- 그래서 `UNION ALL` 방식으로 작성하면 브랜치 별로 인덱스 스캔 시작점을 알 수 있어 Range Scan이 가능하다.

```sql
/* 오라클이 내부적으로 처리하는 논리적 구조 */
SELECT * FROM 사원 WHERE 사원번호 = 10
UNION ALL
SELECT * FROM 사원 WHERE 사원번호 = 20
UNION ALL
SELECT * FROM 사원 WHERE 사원번호 = 30
```

- 아니면 자동으로 SQL 옵티마이저가 `IN-List Iterator` 방식을 사용해서 List 갯수만큼 Index Range Scan을 반복한다. 
- `IN-List Iterator`는 쿼리를 지저분하게 `UNION ALL`로 직접 쓰지 않아도, 똑같은 성능 효과(인덱스 시작점 개별 탐색)를 내게 해주는 오라클의 자동 반복 기능이다.

- 진짜 `UNION ALL` 로 바뀌는 경우 (= `OR Expansion`)
	- 오라클 옵티마이저가 쿼리를 분석하다가 IN이나 OR를 만나면? 
	- 아예 쿼리 구조 자체를 `SELECT ... UNION ALL SELECT ...` 형태로 물리적으로 쪼개버립니다. 
	- 이를 `OR Expansion` 이라고 부릅니다.
    
- `IN-List Iterator` 로 작동하는 경우
	- `OR Expansion`과 다르게 쿼리 구조는 그대로 둡니다.
	- 다만, `IN-List Iterator`는 실행 단계에서 반복해서 수행하는 것입니다.
	- 즉, **실행 엔진(Execution Engine)** 이 IN 안에 들어있는 값의 개수만큼 인덱스 탐색을 루프(Loop) 돌리는 방식입니다.

- 왜 `UNION ALL`로 안 바꾸고 `Iterator`를 쓸까?
	- 만약 `IN (1, 2, 3, ..., 100)` 처럼 값이 100개라면?
		- 이걸 진짜 UNION ALL 100개로 바꾸면 SQL 문장이 너무 길어지고 메모리(Shared Pool)도 많이 잡아먹게 됩니다.
	- 그래서 오라클이 쿼리는 유지하고, 대신 실행할 때만 **INLIST ITERATOR** 라는 반복 기계를 꺼내는 것입니다.
		- 이 기계에 (1, 2, 3...100)이라는 명단을 넣어주고, 
		- **"명단에 있는 값마다 인덱스 시작점을 찾아서(Range Scan) 결과를 가져와!"** 라고 명령하는 것입니다.

### 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스 **선두 컬럼이 조건절에 가공하지 않은 상태로** 있어야 한다는 점은 중요하다.
	- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면, 인덱스 Range Sacn은 무조건 가능하기 때문이다.

- 하지만 Range Scan을 한다고 해도, 인덱스 리프 블록에서 스캔하는 양을 따져보면 성능이 안 좋은 경우도 있다. 
	- 인덱스를 타도 스캔해야 하는 리프블록 범위가 너무 넓기 때문이다. 

### 2.2.4 인덱스를 이용한 소트 연산 생략

- 인덱스는 정렬되어 있다. 
- 그래서 SQL에 ORDER BY 가 있어도 실행계획에선 SORT ORDER BY 없이 실행된다. 
- `INDEX (RANGE SCAN DESCENDING) OF ...` 를 보면 인덱스 자체로 내림차순, 오름차순을 시행함을 알 수 있다. 

### 2.2.5 ORDER BY 절에서 컬럼 가공

- ORDER BY에 쓰인 컬럼명은 테이블 컬럼명이 아닌 SELECT-LIST에 적힌 컬럼명이다. 
- 그래서 SELECT-LIST에서 가공된 컬럼명이 Alias로 적혀 있으면, 해당 가공된 컬럼을 기준으로 SORT ORDER BY 연산이 실행계획에 나타난다. 

* 친절한 SQL튜닝 98~99페이지 참고하기

### 2.2.6 SELECT-LIST에서 컬럼 가공

- 인덱스를 이용해 최댓값 또는 최소값을 구할때는, 인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 레코드 하나(FIRST ROW)만 읽고 멈춘다. 

### 2.2.7 자동 형변환

```sql
select * from cust_base
where 생년월일 = 19881225
```

생년월일 컬럼이 문자열인데, 조건절 비교값을 숫자형으로 표현한다면 오라클 DBMS는 자동으로 형변환 처리를 해준다. 


```sql
select * from cust_base
where TO_NUMBER(생년월일) = 19881225
```

- 숫자형 vs 문자형 
    - 숫자형 기준으로 문자형 컬럼을 변환한다. 
    - LIKE 연산자는 반대이다! LIKE가 문자열 비교 연산자이기 때문이다. 

- 날짜형 vs 문자형
    - 날짜형 기준으로 문자형 컬럼을 변환한다. 

- decode 형변환 주의
    - decode(a, b, c, d) 에서 c의 데이터타입을 기준으로 반환값의 데이터 타입이 결정된다. 
    - 세 번째 인자가 null 이라면 varchar2로 취급된다. 
    - decode(job, 'PRESIDENT', to_number(NULL), sal) 로 NULL의 데이터타입을 명시해줘야 한다. 
