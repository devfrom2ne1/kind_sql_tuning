# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

- 테이블 저장 구조를 개선해서 테이블 랜덤 액세스를 최소화하는 방법들이다.

### 3.1.1 테이블 랜덤 액세스

#### 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?

- 대량 데이터를 조회하는 순간, 인덱스를 사용하니 테이블 전체를 스캔할 때보다 느려졌다.
- 그 이유는 뭘까?
	- 인덱스로 찾은 건 ROWID일 뿐이다.
	- ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때는 디스크에서 블록을 찾아 버퍼캐시에 적재한 후 읽는다.
	- 이 때, 디스크 I/O과정을 많이 거쳐야 한다. 
	- 만약, 모든 데이터가 캐싱되어 있더라도, 테이블 레코드를 찾기 위해 매번 'DBA 해싱'과 '래치 획득' 과정을 반복해야 한다.
	- 동시 액세스가 심할 때는 '캐시버퍼 체인 래치'와 '버퍼 Lock'에 대한 경합까지 발생한다. 	

- 인덱스 ROWID는 물리적 or 논리적?
    - '논리적' 주소에 가깝다.
    - 물리적 메모리 주소값을 저장하는 '포인터'와는 완전히 다른 것이다. 
    - ROWID는 디스크 상에서 레코드를 찾아가기 위한 위치 정보를 담고 있기 때문이다. 
    - 테이블 레코드와 물리적으로 직접 연결되어 있지 않아서 '논리적' 주소에 가깝다. 
    - 마치, [ROWID = 우편주소] / [포인터 = 전화번호]로 비유할 수 있다.  

- DBA정보 획득 차이
    - 인덱스로 테이블 블록 액세스할 때
        - 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보 얻음

    - 테이블 Full Scan할 때
        - 익스텐트 맵을 통해 읽을 블록들의 DBA정보를 얻음

- 인덱스 스캔을 하는 이유는?
    - 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고,
    - 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻기 위함이다. 
	- 만약 대용량 데이터라면, 테이블을 직접 접근하는 것보다 인덱스를 거쳐서 테이블에 접근하면 비효율적이다.

- 메인 메모리 DB(MMDB)와 비교해보자!
    - MMDB는 데이터를 모두 '메모리'에 올려놔서, 디스크를 경유하지 않고 데이터를 읽는다.
    - 그래서 속도가 아주 빠르다. 
    - 반면, 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가 캐싱된다. 
    - 그때마다 다른 공간에 캐싱되기 때문에, 인덱스에서 포인터로 직접 연결할 수 없다. 
    - '메모리 주소 정보(포인터)'가 아니라 '디스크 주소 정보(DBA)'를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다. 


### 3.1.2 인덱스 클러스터링 팩터

#### 클러스터링 팩터(Clustering Factor = 군집성계수 = CF)란?
- 인덱스의 정렬 순서와 실제 테이블 데이터의 정렬 순서가 얼마나 일치하는지를 나타내는 지표입니다.
	- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.

- CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다. 
    - I/O가 적게 발생하기 때문이다. 
    - CF가 나쁘면 논리적 I/O횟수가 늘고, 물리적 I/O 횟수도 는다. 
		- Good CF : 인덱스 레코드 순서대로 테이블을 읽을 때, 다음 레코드도 같은 데이터 블록에 있을 확률이 높습니다.
		- Bad CF : 다음 레코드를 읽을 때마다 매번 다른 데이터 블록으로 건너뛰어야 합니다.

#### 버퍼 피닝(Buffer Pinning)이란?
- 한 번 읽은 데이터 블록을 버퍼 캐시에서 내려놓지 않고, 핀(Pin)을 꽂아 고정해두는 기능입니다.
- 동일한 블록을 다시 방문할 때, 래치(Latch)를 획득하고 해시 체인을 스캔하는 복잡한 과정을 생략하고 즉시 블록에 접근할 수 있게 해줍니다.

#### CF와 버퍼 피닝의 상관관계

| 구분 | 클러스터링 팩터가 좋을 때 | 클러스터링 팩터가 나쁠 때 |
|---|---|---|
| 액세스 패턴 | 인덱스 A→B→C 레코드가 모두 1번 테이블 블록에 있음 | 인덱스 A(1번 블록) → B(5번 블록) → C(1번 블록) |
| 버퍼 피닝 작동 | 1번 블록을 한 번만 Pin 하면 A, B, C를 모두 처리할 때까지 재사용 가능 | A 처리 후 5번 블록으로 가면서 1번 Pin 해제 → C 처리 시 다시 1번 블록을 찾는 과정(I/O) 반복 |
| 효과 | 논리적 I/O(Consistent Gets) 대폭 감소 | 논리적 I/O가 레코드 수만큼 발생 |

- 오라클과 같은 DB 엔진은 인덱스를 통해 테이블을 액세스할 때, 보통 직전에 방문했던 블록의 주소를 기억하고 이를 '피닝' 상태로 유지합니다.

- 클러스터링 팩터가 좋은 인덱스는 버퍼 피닝 덕분에 대량의 데이터를 인덱스로 읽어도 테이블 풀 스캔(Full Table Scan)보다 훨씬 빠를 수 있습니다.
- 버퍼 피닝은 블록을 찾는 과정(래치 획득)을 생략하므로, CPU 사용량을 줄이고 동시 사용자가 많을 때 발생하는 래치 경합을 완화합니다.

- 따라서, 클러스터링 팩터가 좋을수록 버퍼 피닝의 효과가 극대화되어 논리적 I/O가 획기적으로 줄어든다.
	- 데이터가 잘 모여 있어야(CF가 좋아야) 한 번 잡은 블록을 놓지 않고 계속 쓸 수 있는(Pinning) 기회가 생기기 때문이다.



### 3.1.3 인덱스 손익분기점

- '인덱스 테이블 액세스'가 '테이블 풀 스캔' 보다 느린 핵심 요인은?
    - 시퀀셜 액세스 vs 랜덤 액세스
    - 멀티블록 I/O vs 싱글블록 I/O
    - Table Full Scan : 시퀀셜액세스와 멀티블록
    - 인덱스 테이블 스캔 : 랜덤 액세스와 싱글블록
    - 💡 ** 그래서 이유가 뭔데? **  

- 인덱스 손익분기점 & 버퍼캐시 히트율
    - 조회 건수가 늘수록 버퍼캐시에서 데이터를 찾을 가능성이 작아진다. 
    - 그래서 조회 건수가 늘수록 성능이 느려진다.
    - 특정 테이블을 인덱스로 100만 건 이상 액세스하면, 캐시 히트율은 낮아진다. 
    - 1000만 건 테이블이면 인덱스 컬럼 기준으로 값이 같은 테이블 레코드가 근처에 모여있을 가능성이 적다. 
    - 그래서 인덱스 스캔하면서 거의 모든 데이터를 디스크에서 읽게 된다. 
    - 만 건만 넘어도, 시퀀셜액세스와 멀티블록방식(Table Full Scan)으로 읽는 게 더 빠를 수 있다. 

- 배치 vs Online
    - 배치는 전체 데이터를 읽고 처리하는 반면, 온라인 프로그램은 소량 데이터를 읽고 갱신한다. 
    - 소량 데이터는 인덱스와 NL조인이 유리하다. 
    - 대량 데이터는 Full Scan과 해시조인이 유리하다. 
    - 하지만, 초대용량은 파티셔닝 전략이 중요한 튜닝 요소이다. 병렬처리까지 하면 좋다. 


### 3.1.4 인덱스 컬럼 추가

### 3.1.5 인덱스만 읽고 처리

#### Coverd Index

#### Include Index


### 3.1.6 인덱스 구조 테이블

- IOT(Index Organized Table, 인덱스 구조 테이블)은 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성하는 것이다. 

- ROWID를 갖지 않고, 그 자리에 테이블 데이터를 갖는다. 인덱스 리프블록이 곧 데이터블록인 셈이다. 

- IOT는 정렬된 상태로 모여 있으므로, 클러스터링 팩터가 좋다. 
    - between이나 부등호 조건으로 넒은 범위를 읽을 떄 유리하다. 

### 3.1.7 클러스터 테이블

- 인덱스 클러스터와 해시 클러스터 두 가지가 있다. 

#### 인덱스 클러스터

- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 
- 한 블록에 안담길 때는, 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 
- 하지만 IOT랑 달리 정렬은 안되어 있다. 
- B*Tree 인덱스 구조를 사용하지만, 첫 번째 데이터 블록을 가리킨다. 
- 그래서 테이블 레코드와 1:M 구조를 갖는다. 
- 즉 랜덤 액세스가 값 하나 당 한 번씩밖에 발생하지 않기 때문에, 비효율이 없다.

#### 해시 클러스터 

- 해시 클러스터는 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다. 