# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

- 테이블 저장 구조를 개선해서 테이블 랜덤 액세스를 최소화하는 방법들이다.

### 3.1.1 테이블 랜덤 액세스

#### 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?

- 대량 데이터를 조회하는 순간, 인덱스를 사용하니 테이블 전체를 스캔할 때보다 느려졌다.
- 그 이유는 뭘까?
	- 인덱스로 찾은 건 ROWID일 뿐이다.
	- ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때는 디스크에서 블록을 찾아 버퍼캐시에 적재한 후 읽는다.
	- 이 때, 디스크 I/O과정을 많이 거쳐야 한다. 
	- 만약, 모든 데이터가 캐싱되어 있더라도, 테이블 레코드를 찾기 위해 매번 'DBA 해싱'과 '래치 획득' 과정을 반복해야 한다.
	- 동시 액세스가 심할 때는 '캐시버퍼 체인 래치'와 '버퍼 Lock'에 대한 경합까지 발생한다. 	

- 인덱스 ROWID는 물리적 or 논리적?
    - '논리적' 주소에 가깝다.
    - 물리적 메모리 주소값을 저장하는 '포인터'와는 완전히 다른 것이다. 
    - ROWID는 디스크 상에서 레코드를 찾아가기 위한 위치 정보를 담고 있기 때문이다. 
    - 테이블 레코드와 물리적으로 직접 연결되어 있지 않아서 '논리적' 주소에 가깝다. 
    - 마치, [ROWID = 우편주소] / [포인터 = 전화번호]로 비유할 수 있다.  

- DBA정보 획득 차이
    - 인덱스로 테이블 블록 액세스할 때
        - 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보 얻음

    - 테이블 Full Scan할 때
        - 익스텐트 맵을 통해 읽을 블록들의 DBA정보를 얻음

- 인덱스 스캔을 하는 이유는?
    - 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고,
    - 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻기 위함이다. 
	- 만약 대용량 데이터라면, 테이블을 직접 접근하는 것보다 인덱스를 거쳐서 테이블에 접근하면 비효율적이다.

- 메인 메모리 DB(MMDB)와 비교해보자!
    - MMDB는 데이터를 모두 '메모리'에 올려놔서, 디스크를 경유하지 않고 데이터를 읽는다.
    - 그래서 속도가 아주 빠르다. 
    - 반면, 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가 캐싱된다. 
    - 그때마다 다른 공간에 캐싱되기 때문에, 인덱스에서 포인터로 직접 연결할 수 없다. 
    - '메모리 주소 정보(포인터)'가 아니라 '디스크 주소 정보(DBA)'를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다. 


### 3.1.2 인덱스 클러스터링 팩터

#### 클러스터링 팩터(Clustering Factor = 군집성계수 = CF)란?
- 인덱스의 정렬 순서와 실제 테이블 데이터의 정렬 순서가 얼마나 일치하는지를 나타내는 지표입니다.
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.

- CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다. 
    - I/O가 적게 발생하기 때문이다. 
    - CF가 나쁘면 논리적 I/O횟수가 늘고, 물리적 I/O 횟수도 는다. 
	- Good CF : 인덱스 레코드 순서대로 테이블을 읽을 때, 다음 레코드도 같은 데이터 블록에 있을 확률이 높습니다.
	- Bad CF : 다음 레코드를 읽을 때마다 매번 다른 데이터 블록으로 건너뛰어야 합니다.

#### 버퍼 피닝(Buffer Pinning)이란?
- 한 번 읽은 데이터 블록을 버퍼 캐시에서 내려놓지 않고, 핀(Pin)을 꽂아 고정해두는 기능입니다.
- 동일한 블록을 다시 방문할 때, 래치(Latch)를 획득하고 해시 체인을 스캔하는 복잡한 과정을 생략하고 즉시 블록에 접근할 수 있게 해줍니다.

#### CF와 버퍼 피닝의 상관관계

| 구분 | 클러스터링 팩터가 좋을 때 | 클러스터링 팩터가 나쁠 때 |
|---|---|---|
| 액세스 패턴 | 인덱스 A→B→C 레코드가 모두 1번 테이블 블록에 있음 | 인덱스 A(1번 블록) → B(5번 블록) → C(1번 블록) |
| 버퍼 피닝 작동 | 1번 블록을 한 번만 Pin 하면 A, B, C를 모두 처리할 때까지 재사용 가능 | A 처리 후 5번 블록으로 가면서 1번 Pin 해제 → C 처리 시 다시 1번 블록을 찾는 과정(I/O) 반복 |
| 효과 | 논리적 I/O(Consistent Gets) 대폭 감소 | 논리적 I/O가 레코드 수만큼 발생 |

- 오라클과 같은 DB 엔진은 인덱스를 통해 테이블을 액세스할 때, 보통 직전에 방문했던 블록의 주소를 기억하고 이를 '피닝' 상태로 유지합니다.

- 클러스터링 팩터가 좋은 인덱스는 버퍼 피닝 덕분에 대량의 데이터를 인덱스로 읽어도 테이블 풀 스캔(Full Table Scan)보다 훨씬 빠를 수 있습니다.
- 버퍼 피닝은 블록을 찾는 과정(래치 획득)을 생략하므로, CPU 사용량을 줄이고 동시 사용자가 많을 때 발생하는 래치 경합을 완화합니다.

- 따라서, 클러스터링 팩터가 좋을수록 버퍼 피닝의 효과가 극대화되어 논리적 I/O가 획기적으로 줄어든다.
	- 데이터가 잘 모여 있어야(CF가 좋아야) 한 번 잡은 블록을 놓지 않고 계속 쓸 수 있는(Pinning) 기회가 생기기 때문이다.



### 3.1.3 인덱스 손익분기점
Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익분기점'이라고 한다.
- Table Full Scan은 성능이 일정하다.
- Index Range Scan은 전체 중 몇 건을 추출하느냐에 따라 성능이 달라진다.(많을수록 느려짐)

#### '인덱스 테이블 액세스'가 '테이블 풀 스캔' 보다 느린 핵심 요인은?

| 구분 | 인덱스 테이블 액세스 | 테이블 풀 스캔 (Full Scan) |
|---|---|---|
| I/O 단위 | Single Block I/O (느림) | Multiblock I/O (빠름) |
| 접근 방식 | Random Access (불연속적) | Sequential Access (연속적) |
| 유리한 경우 | 소량의 데이터 추출 (선택도 높음) | 대량의 데이터 추출 (선택도 낮음) |

1. Single Block I/O vs Multiblock I/O
	- 가장 결정적인 물리적 요인은 한 번의 I/O 작업으로 **'얼마나 많은 데이터를 가져오는가'** 입니다.
	- 인덱스 액세스 (Single Block I/O)
		- 인덱스를 타고 테이블을 읽을 때는 한 번에 단 하나의 블록씩만 요청합니다. 
		- 100개의 블록을 읽으려면 100번의 I/O Call이 발생합니다.
	- 테이블 풀 스캔 (Multiblock I/O)
		- 테이블 전체를 읽을 때는 한 번의 I/O Call로 **여러 개의 인접한 블록(보통 64~128개)** 을 한꺼번에 메모리로 퍼올립니다.
   	- 비유하자면, 인덱스는 한 국자씩 물을 퍼 나르는 것이고, 풀 스캔은 큰 양동이로 한 번에 퍼 나르는 것과 같습니다. 읽어야 할 양이 많아질수록 양동이가 훨씬 효율적입니다.

2. Random Access vs Sequential Access
	- 데이터에 접근하는 경로의 복잡성 차이입니다.
	- 인덱스 액세스 (Random Access)
		- 인덱스 리프 블록에서 얻은 ROWID를 가지고 테이블 블록을 찾아갑니다. 
		- 이때 인덱스 순서와 테이블의 물리적 저장 순서가 다르면(클러스터링 팩터가 나쁘면), 이리저리 건너뛰며 블록을 찾는 랜덤 액세스 부하가 극심해집니다.
	- 테이블 풀 스캔 (Sequential Access)
		- 물리적으로 연결된 블록들을 순서대로 쭉 읽어 내려갑니다. 	
		- 헤드가 움직이는 범위가 최소화되며, 다음 읽을 블록을 미리 예측하여 가져오는 'Prefetch' 기능도 매우 효과적으로 작동합니다.

3. 버퍼 캐시 히트율(BCHR)과 '캐시 오염' 요인
	- 조회 건수가 늘어날수록 성능이 급격히 떨어지는 이유는 단순히 읽을 양이 많아서뿐만 아니라, 버퍼 캐시의 효율성이 무너지기 때문입니다.
	- 반복 방문의 한계 : 인덱스 액세스는 테이블 블록을 '한 번에 하나씩' 호출합니다. 
		- 100만 건을 읽을 때 100만 번의 블록 호출이 발생하는데, 캐시 크기보다 읽어야 할 블록의 범위가 넓어지면(Bad CF 상황 등), 
		- 방금 읽었던 블록이 캐시에서 밀려나고 다시 디스크에서 읽어오는 **'캐시 미스'** 가 반복됩니다.
	- 물리적 디스크 I/O 발생 : 결국 캐시 히트율이 낮아지면 싱글 블록 I/O가 모두 물리적 디스크 읽기로 이어지며 성능이 기하급수적으로 느려집니다.

4. 클러스터링 팩터의 열화 (데이터 분포도)
	- 테이블 규모가 커질수록(예: 1,000만 건 이상), 특정 인덱스 키 값이 물리적으로 여러 블록에 흩어져 저장될 가능성이 큽니다.
	- 데이터가 여기저기 흩어져 있으면 인덱스 리프 블록을 따라가며 테이블을 읽을 때, 거의 매번 새로운 블록을 로드해야 합니다.
	- 손익분기점의 붕괴 : 만 건만 넘어도 '한 번에 많이, 순차적으로' 읽는 풀 스캔(Full Scan)이 훨씬 효율적인 역전 현상이 발생합니다.

5. 업무 성격(OLTP vs. Batch)에 따른 최적화 차이
	- 성능을 결정하는 또 다른 요인은 '응답 시간(Response Time) vs 처리량(Throughput)' 중 무엇을 우선하느냐입니다.
	- 온라인(Online): 사용자 한 명에게 빠른 결과를 줘야 하므로 인덱스 + NL 조인을 통해 첫 번째 레코드를 빠르게 반환하는 것이 중요합니다.
	- 배치(Batch): 전체 데이터를 가장 효율적으로 처리해야 하므로, 개별 I/O 비용을 줄이는 Full Scan + 해시 조인 + 병렬 처리가 정답이 됩니다.

- 대용량 처리를 위한 최종 병기 : 파티셔닝(Partitioning)
	- 데이터가 너무 많아지면 인덱스만으로는 한계가 있습니다. 
	- 이때는 **'파티션 프루닝(Partition Pruning)'** 이 핵심 요인이 됩니다.
	- 범위 축소: 전체 테이블을 다 읽지 않고 필요한 파티션만 골라 풀 스캔함으로써, 인덱스의 장점(범위 제한)과 풀 스캔의 장점(멀티 블록 I/O)을 동시에 취할 수 있습니다.

#### (예시) 고객구분코드가 'A001'인 고객의 최근 1년 이내 변경 이력 중 전월 말일 데이터를 읽어 고객_임시 테이블에 입력하기

- 전체 고객 : 300만 명
- 조건 만족 고객 : 100만 명

- 안좋은 예시

```sql
insert into 고객_임시
select c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c, 고객변경이력 h
where c.고객구분코드 = 'A001'
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
				from 고객변경이력
				where 고객번호 = c.고객번호
				and 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
				and 변경일시 < trunc(sysdate, 'mm'))
```

- Full Scan + 해시조인

```sql
insert into 고객_임시
select /*+ full(c) full(h) index_ffs(m.고객변경이력)
			ordered no_merge(m) use_hash(m) use_hash(h) */
		c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c
	, (select 고객번호, max(변경일시) 최종변경일시
	   from 고객변경이력
	   where 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
	   and 변경일시 < trunc(sysdate, 'mm')
 	   group by 고객번호
	) m
    , 고객변경이력 h
where c.고객구분코드 = 'A001'
and m.고객번호 = c.고객번호
and h.고객번호 = m.고객번호
and h.변경일시 = m.최종변경일시
```

- 윈도우함수 이용하기
	- 테이블을 두 번 읽는 비효율을 없앨 수 있다.

```sql
insert into 고객_임시
select 고객번호, 고객명, 전화번호, 주소, 상태코드, 변경일시
from (
	select /*+ full(c) full(h) leading(c) use_hash(h) */
		c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
		, rank() over (partition by h.고객번호 order by h.변경일시 desc) ㅜㅐ
	from 고객 c, 고객변경이력 h
	where c.고객구분코드 = 'A001'
    and h.변경일시 >= trunc(add_months(sysdate, -12), 'mm')
	and h.변경일시 < trunc(sysdate, 'mm')
	and h.고객번호 = c.고객번호
)
where no = 1
```

### 3.1.4 인덱스 컬럼 추가

### 3.1.5 인덱스만 읽고 처리

#### Coverd Index

#### Include Index


### 3.1.6 인덱스 구조 테이블

- IOT(Index Organized Table, 인덱스 구조 테이블)은 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성하는 것이다. 

- ROWID를 갖지 않고, 그 자리에 테이블 데이터를 갖는다. 인덱스 리프블록이 곧 데이터블록인 셈이다. 

- IOT는 정렬된 상태로 모여 있으므로, 클러스터링 팩터가 좋다. 
    - between이나 부등호 조건으로 넒은 범위를 읽을 떄 유리하다. 

### 3.1.7 클러스터 테이블

- 인덱스 클러스터와 해시 클러스터 두 가지가 있다. 

#### 인덱스 클러스터

- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 
- 한 블록에 안담길 때는, 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 
- 하지만 IOT랑 달리 정렬은 안되어 있다. 
- B*Tree 인덱스 구조를 사용하지만, 첫 번째 데이터 블록을 가리킨다. 
- 그래서 테이블 레코드와 1:M 구조를 갖는다. 
- 즉 랜덤 액세스가 값 하나 당 한 번씩밖에 발생하지 않기 때문에, 비효율이 없다.

#### 해시 클러스터 

- 해시 클러스터는 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다. 