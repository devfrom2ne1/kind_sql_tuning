# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

- 테이블 저장 구조를 개선해서 테이블 랜덤 액세스를 최소화하는 방법들이다.

### 3.1.1 테이블 랜덤 액세스

#### 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?

- 대량 데이터를 조회하는 순간, 인덱스를 사용하니 테이블 전체를 스캔할 때보다 느려졌다. 그 이유는 뭘까?

- 인덱스 스캔을 하는 이유는?
    - 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고,
    - 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻기 위함이다. 

- 인덱스 ROWID는 물리적 or 논리적?
    - '논리적' 주소에 가깝다.
    - 물리적 메모리 주소값을 저장하는 '포인터'와는 완전히 다른 것이다. 
    - ROWID는 디스크 상에서 레코드를 찾아가기 위한 위치 정보를 담고 있기 때문이다. 
    - 테이블 레코드와 물리적으로 직접 연결되어 있지 않아서 '논리적' 주소에 가깝다. 
    - 마치, [ROWID = 우편주소] / [포인터 = 전화번호]로 비유할 수 있다.  

- 메인 메모리 DB(MMDB)와 비교해보자!
    - MMDB는 데이터를 모두 '메모리'에 올려놔서, 디스크를 경유하지 않고 데이터를 읽는다.
    - 그래서 속도가 아주 빠르다. 
    - 반면, 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가 캐싱된다. 
    - 그때마다 다른 공간에 캐싱되기 때문에, 인덱스에서 포인터로 직접 연결할 수 없다. 
    - '메모리 주소 정보(포인터)'가 아니라 '디스크 주소 정보(DBA)'를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다. 

- I/O 메커니즘
    - DBA(데이터파일번호 + 블록번호) : 디스크 상에서 블록을 찾기 위한 주소
    - 버퍼캐시 : 최근 사용된 디스크 블록을 메모리에 캐시하는 것

    - I/O 메커니즘
        - 블록을 읽을 때, 디스크로 가기 전 버퍼캐시부터 찾음 
        - 읽고자 하는 DBA를 해시함수에 입력해서 --> 해시체인 찾고 --> 버퍼 헤더 찾음 --> 메모리 주소값(포인터)를 읽어서 --> 버퍼 블록 찾아감

    - 인덱스로 테이블 블록 액세스할 때
        - 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보 얻음

    - 테이블 Full Scan할 때
        - 익스텐트 맵을 통해 읽을 블록들의 DBA정보를 얻음

- 💡 ** 그래서 이유가 뭔데? **
    - 3.1.3에 정답이 있음(인덱스 손익 분기점)

### 3.1.2 인덱스 클러스터링 팩터

- 클러스터링 팩터(군집성계수, CF) : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도

- CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다. 
    - I/O가 적게 발생하기 떄문이다. 
    - CF가 나쁘면 논리적 I/O횟수가 늘고, 물리적 I/O 횟수도 는다. 

- 📷 책 136~137p. CF가 좋은 인덱스와 안좋은 인덱스 그림

### 3.1.3 인덱스 손익분기점

- '인덱스 테이블 액세스'가 '테이블 풀 스캔' 보다 느린 핵심 요인은?
    - 시퀀셜 액세스 vs 랜덤 액세스
    - 멀티블록 I/O vs 싱글블록 I/O
    - Table Full Scan : 시퀀셜액세스와 멀티블록
    - 인덱스 테이블 스캔 : 랜덤 액세스와 싱글블록
    - 💡 ** 그래서 이유가 뭔데? **  

- 인덱스 손익분기점 & 버퍼캐시 히트율
    - 조회 건수가 늘수록 버퍼캐시에서 데이터를 찾을 가능성이 작아진다. 
    - 그래서 조회 건수가 늘수록 성능이 느려진다.
    - 특정 테이블을 인덱스로 100만 건 이상 액세스하면, 캐시 히트율은 낮아진다. 
    - 1000만 건 테이블이면 인덱스 컬럼 기준으로 값이 같은 테이블 레코드가 근처에 모여있을 가능성이 적다. 
    - 그래서 인덱스 스캔하면서 거의 모든 데이터를 디스크에서 읽게 된다. 
    - 만 건만 넘어도, 시퀀셜액세스와 멀티블록방식(Table Full Scan)으로 읽는 게 더 빠를 수 있다. 

- 배치 vs Online
    - 배치는 전체 데이터를 읽고 처리하는 반면, 온라인 프로그램은 소량 데이터를 읽고 갱신한다. 
    - 소량 데이터는 인덱스와 NL조인이 유리하다. 
    - 대량 데이터는 Full Scan과 해시조인이 유리하다. 
    - 하지만, 초대용량은 파티셔닝 전략이 중요한 튜닝 요소이다. 병렬처리까지 하면 좋다. 


### 3.1.4 인덱스 컬럼 추가

### 3.1.5 인덱스만 읽고 처리

#### Coverd Index

#### Include Index


### 3.1.6 인덱스 구조 테이블

- IOT(Index Organized Table, 인덱스 구조 테이블)은 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성하는 것이다. 

- ROWID를 갖지 않고, 그 자리에 테이블 데이터를 갖는다. 인덱스 리프블록이 곧 데이터블록인 셈이다. 

- IOT는 정렬된 상태로 모여 있으므로, 클러스터링 팩터가 좋다. 
    - between이나 부등호 조건으로 넒은 범위를 읽을 떄 유리하다. 

### 3.1.7 클러스터 테이블

- 인덱스 클러스터와 해시 클러스터 두 가지가 있다. 

#### 인덱스 클러스터

- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 
- 한 블록에 안담길 때는, 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 
- 하지만 IOT랑 달리 정렬은 안되어 있다. 
- B*Tree 인덱스 구조를 사용하지만, 첫 번째 데이터 블록을 가리킨다. 
- 그래서 테이블 레코드와 1:M 구조를 갖는다. 
- 즉 랜덤 액세스가 값 하나 당 한 번씩밖에 발생하지 않기 때문에, 비효율이 없다.

#### 해시 클러스터 

- 해시 클러스터는 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다. 