
# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

- 테이블 저장 구조를 개선해서 테이블 랜덤 액세스를 최소화하는 방법들이다.

### 3.1.1 테이블 랜덤 액세스

#### 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?

- 대량 데이터를 조회하는 순간, 인덱스를 사용하니 테이블 전체를 스캔할 때보다 느려졌다.
- 그 이유는 뭘까?
	- 인덱스로 찾은 건 ROWID일 뿐이다.
	- ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때는 디스크에서 블록을 찾아 버퍼캐시에 적재한 후 읽는다.
	- 이 때, 디스크 I/O과정을 많이 거쳐야 한다. 
	- 만약, 모든 데이터가 캐싱되어 있더라도, 테이블 레코드를 찾기 위해 매번 'DBA 해싱'과 '래치 획득' 과정을 반복해야 한다.
	- 동시 액세스가 심할 때는 '캐시버퍼 체인 래치'와 '버퍼 Lock'에 대한 경합까지 발생한다. 	

- 인덱스 ROWID는 물리적 or 논리적?
    - '논리적' 주소에 가깝다.
    - 물리적 메모리 주소값을 저장하는 '포인터'와는 완전히 다른 것이다. 
    - ROWID는 디스크 상에서 레코드를 찾아가기 위한 위치 정보를 담고 있기 때문이다. 
    - 테이블 레코드와 물리적으로 직접 연결되어 있지 않아서 '논리적' 주소에 가깝다. 
    - 마치, [ROWID = 우편주소] / [포인터 = 전화번호]로 비유할 수 있다.  

- DBA정보 획득 차이
    - 인덱스로 테이블 블록 액세스할 때
        - 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보 얻음

    - 테이블 Full Scan할 때
        - 익스텐트 맵을 통해 읽을 블록들의 DBA정보를 얻음

- 인덱스 스캔을 하는 이유는?
    - 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고,
    - 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻기 위함이다. 
	- 만약 대용량 데이터라면, 테이블을 직접 접근하는 것보다 인덱스를 거쳐서 테이블에 접근하면 비효율적이다.

- 메인 메모리 DB(MMDB)와 비교해보자!
    - MMDB는 데이터를 모두 '메모리'에 올려놔서, 디스크를 경유하지 않고 데이터를 읽는다.
    - 그래서 속도가 아주 빠르다. 
    - 반면, 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가 캐싱된다. 
    - 그때마다 다른 공간에 캐싱되기 때문에, 인덱스에서 포인터로 직접 연결할 수 없다. 
    - '메모리 주소 정보(포인터)'가 아니라 '디스크 주소 정보(DBA)'를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다. 


### 3.1.2 인덱스 클러스터링 팩터

#### 클러스터링 팩터(Clustering Factor = 군집성계수 = CF)란?
- 인덱스의 정렬 순서와 실제 테이블 데이터의 정렬 순서가 얼마나 일치하는지를 나타내는 지표입니다.
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.

- CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다. 
    - I/O가 적게 발생하기 때문이다. 
    - CF가 나쁘면 논리적 I/O횟수가 늘고, 물리적 I/O 횟수도 는다. 
	- Good CF : 인덱스 레코드 순서대로 테이블을 읽을 때, 다음 레코드도 같은 데이터 블록에 있을 확률이 높습니다.
	- Bad CF : 다음 레코드를 읽을 때마다 매번 다른 데이터 블록으로 건너뛰어야 합니다.

#### 버퍼 피닝(Buffer Pinning)이란?
- 한 번 읽은 데이터 블록을 버퍼 캐시에서 내려놓지 않고, 핀(Pin)을 꽂아 고정해두는 기능입니다.
- 동일한 블록을 다시 방문할 때, 래치(Latch)를 획득하고 해시 체인을 스캔하는 복잡한 과정을 생략하고 즉시 블록에 접근할 수 있게 해줍니다.

#### CF와 버퍼 피닝의 상관관계

| 구분 | 클러스터링 팩터가 좋을 때 | 클러스터링 팩터가 나쁠 때 |
|---|---|---|
| 액세스 패턴 | 인덱스 A→B→C 레코드가 모두 1번 테이블 블록에 있음 | 인덱스 A(1번 블록) → B(5번 블록) → C(1번 블록) |
| 버퍼 피닝 작동 | 1번 블록을 한 번만 Pin 하면 A, B, C를 모두 처리할 때까지 재사용 가능 | A 처리 후 5번 블록으로 가면서 1번 Pin 해제 → C 처리 시 다시 1번 블록을 찾는 과정(I/O) 반복 |
| 효과 | 논리적 I/O(Consistent Gets) 대폭 감소 | 논리적 I/O가 레코드 수만큼 발생 |

- 오라클과 같은 DB 엔진은 인덱스를 통해 테이블을 액세스할 때, 보통 직전에 방문했던 블록의 주소를 기억하고 이를 '피닝' 상태로 유지합니다.

- 클러스터링 팩터가 좋은 인덱스는 버퍼 피닝 덕분에 대량의 데이터를 인덱스로 읽어도 테이블 풀 스캔(Full Table Scan)보다 훨씬 빠를 수 있습니다.
- 버퍼 피닝은 블록을 찾는 과정(래치 획득)을 생략하므로, CPU 사용량을 줄이고 동시 사용자가 많을 때 발생하는 래치 경합을 완화합니다.

- 따라서, 클러스터링 팩터가 좋을수록 버퍼 피닝의 효과가 극대화되어 논리적 I/O가 획기적으로 줄어든다.
	- 데이터가 잘 모여 있어야(CF가 좋아야) 한 번 잡은 블록을 놓지 않고 계속 쓸 수 있는(Pinning) 기회가 생기기 때문이다.



### 3.1.3 인덱스 손익분기점
Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익분기점'이라고 한다.
- Table Full Scan은 성능이 일정하다.
- Index Range Scan은 전체 중 몇 건을 추출하느냐에 따라 성능이 달라진다.(많을수록 느려짐)

#### '인덱스 테이블 액세스'가 '테이블 풀 스캔' 보다 느린 핵심 요인은?

| 구분 | 인덱스 테이블 액세스 | 테이블 풀 스캔 (Full Scan) |
|---|---|---|
| I/O 단위 | Single Block I/O (느림) | Multiblock I/O (빠름) |
| 접근 방식 | Random Access (불연속적) | Sequential Access (연속적) |
| 유리한 경우 | 소량의 데이터 추출 (선택도 높음) | 대량의 데이터 추출 (선택도 낮음) |

1. Single Block I/O vs Multiblock I/O
	- 가장 결정적인 물리적 요인은 한 번의 I/O 작업으로 **'얼마나 많은 데이터를 가져오는가'** 입니다.
	- 인덱스 액세스 (Single Block I/O)
		- 인덱스를 타고 테이블을 읽을 때는 한 번에 단 하나의 블록씩만 요청합니다. 
		- 100개의 블록을 읽으려면 100번의 I/O Call이 발생합니다.
	- 테이블 풀 스캔 (Multiblock I/O)
		- 테이블 전체를 읽을 때는 한 번의 I/O Call로 **여러 개의 인접한 블록(보통 64~128개)** 을 한꺼번에 메모리로 퍼올립니다.
   	- 비유하자면, 인덱스는 한 국자씩 물을 퍼 나르는 것이고, 풀 스캔은 큰 양동이로 한 번에 퍼 나르는 것과 같습니다. 읽어야 할 양이 많아질수록 양동이가 훨씬 효율적입니다.

2. Random Access vs Sequential Access
	- 데이터에 접근하는 경로의 복잡성 차이입니다.
	- 인덱스 액세스 (Random Access)
		- 인덱스 리프 블록에서 얻은 ROWID를 가지고 테이블 블록을 찾아갑니다. 
		- 이때 인덱스 순서와 테이블의 물리적 저장 순서가 다르면(클러스터링 팩터가 나쁘면), 이리저리 건너뛰며 블록을 찾는 랜덤 액세스 부하가 극심해집니다.
	- 테이블 풀 스캔 (Sequential Access)
		- 물리적으로 연결된 블록들을 순서대로 쭉 읽어 내려갑니다. 	
		- 헤드가 움직이는 범위가 최소화되며, 다음 읽을 블록을 미리 예측하여 가져오는 'Prefetch' 기능도 매우 효과적으로 작동합니다.

3. 버퍼 캐시 히트율(BCHR)과 '캐시 오염' 요인

	- **버퍼 캐시 히트율(Buffer Cache Hit Ratio, BCHR)** 이란?
		- 데이터베이스나 시스템이 필요한 데이터를 찾을 때, 느린 디스크로 가지 않고 빠른 메모리(버퍼 캐시)에서 곧바로 찾아낸 비율을 말합니다.
		- "전체 데이터 요청 중 몇 번이나 메모리에서 한 방에 해결했니?"를 보여주는 비율
	
	- 결국 캐시 히트율이 낮아지면 -> 싱글 블록 I/O가 모두 물리적 디스크 읽기로 이어지며 -> 성능이 기하급수적으로 느려짐

	- '버퍼캐시히트율'이 높으면 무조건 좋은가요?
		- 일반적으로 OLTP(온라인 트랜잭션 처리) 시스템에서는 95%~99% 이상을 목표로 하지만, 숫자가 높다고 해서 반드시 시스템이 최적화되었다는 뜻은 아님
		- 똑같은 데이터를 수천 번 반복해서 읽는 비효율적인 쿼리가 있다면, 메모리에서 계속 읽기 때문에 히트율은 100%에 가깝게 나옴
		- 대규모 배치 작업이나 전체 테이블 스캔(Full Table Scan)을 하면 히트율이 뚝 떨어짐
		- 조회 건수가 늘어날수록 성능이 급격히 떨어지는 이유는 단순히 읽을 양이 많아서뿐만 아니라, 버퍼 캐시의 효율성이 무너지기 때문
			- 100만 건을 읽을 때 100만 번의 블록 호출이 발생하는데,
			- 캐시 크기보다 읽어야 할 블록의 범위가 넓어지면
			- 방금 읽었던 블록이 캐시에서 밀려나고 다시 디스크에서 읽어오는 **'캐시 미스'** 가 반복되며 
			- 버퍼 캐시 효율성이 무너짐
	
4. 클러스터링 팩터의 열화 (데이터 분포도)
	- 테이블 규모가 커질수록(예: 1,000만 건 이상), 특정 인덱스 키 값이 물리적으로 여러 블록에 흩어져 저장될 가능성이 큽니다.
	- 데이터가 여기저기 흩어져 있으면 인덱스 리프 블록을 따라가며 테이블을 읽을 때, 거의 매번 새로운 블록을 로드해야 합니다.
	- 손익분기점의 붕괴 : 만 건만 넘어도 '한 번에 많이, 순차적으로' 읽는 풀 스캔(Full Scan)이 훨씬 효율적인 역전 현상이 발생합니다.

5. 업무 성격(OLTP vs. Batch)에 따른 최적화 차이
	- 성능을 결정하는 또 다른 요인은 '응답 시간(Response Time) vs 처리량(Throughput)' 중 무엇을 우선하느냐입니다.
	- 온라인(Online): 사용자 한 명에게 빠른 결과를 줘야 하므로 "인덱스 + NL 조인"을 통해 첫 번째 레코드를 빠르게 반환하는 것이 중요합니다.
	- 배치(Batch): 전체 데이터를 가장 효율적으로 처리해야 하므로, 개별 I/O 비용을 줄이는 "Full Scan + 해시 조인 + 병렬 처리"가 정답이 됩니다.

- 대용량 처리를 위한 최종 병기 : 파티셔닝(Partitioning)
	- 데이터가 너무 많아지면 인덱스만으로는 한계가 있습니다. 
	- 이때는 **'파티션 프루닝(Partition Pruning)'** 이 핵심 요인이 됩니다.
	- 범위 축소: 전체 테이블을 다 읽지 않고 필요한 파티션만 골라 풀 스캔함으로써, 인덱스의 장점(범위 제한)과 풀 스캔의 장점(멀티 블록 I/O)을 동시에 취할 수 있습니다.

#### (예시) 초대용량 테이블 insert

- 고객구분코드가 'A001'인 고객의 최근 1년 이내 변경 이력 중, 전월 말일 데이터를 읽어 '고객_임시' 테이블에 입력하기
- 전체 고객 : 300만 명
- 조건 만족 고객 : 100만 명

#### 안좋은 예시

```sql
insert into 고객_임시
select c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c, 고객변경이력 h
where c.고객구분코드 = 'A001'
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
				from 고객변경이력
				where 고객번호 = c.고객번호
				and 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
				and 변경일시 < trunc(sysdate, 'mm'))
```

#### Full Scan + 해시조인

- index_ffs(Index Fast Full Scan)
	- 일반적인 인덱스 스캔이 '목차를 보고 페이지를 찾아가는 방식'이라면, index_ffs는 **"데이터 파일은 보지 않고, 인덱스 세그먼트 자체를 하나의 테이블처럼 통째로 읽어버리는 방식"** 
	- 인덱스를 논리적 순서가 아닌, 물리적으로 저장된 순서대로 읽기 때문에 결과값이 인덱스 키 순서로 정렬되지 않습니다.

- 아래 쿼리에서 index_ffs(m.고객변경이력)가 쓰인 이유는 다음과 같습니다.
	- 고객변경이력 테이블의 방대한 데이터 중 필요한 컬럼(고객번호, 변경일시)만 들어있는 인덱스를 테이블처럼 아주 빠르게 통째로 훑기 위해 사용되었습니다.
	- 고객번호와 변경일시 컬럼이 모두 인덱스에 포함되어 있다면, 굳이 무거운 테이블(고객변경이력)에 접근할 필요가 없고, 인덱스만 읽어서도 결과를 낼 수 있기 때문입니다.
	- 또 최근 12개월 치의 방대한 변경 이력 데이터를 빠르게 읽어 max(변경일시)를 구해야 하므로, 멀티 블록 I/O를 사용하는 FFS 방식이 효율적입니다.
	- 정렬이 필요 없는 group by 연산에서 해시 알고리즘을 사용하기 위해, 정렬되지 않은 채로 빠르게 데이터를 퍼 올리는 FFS를 선택한 것입니다.

```sql
insert into 고객_임시
select /*+ full(c) full(h) index_ffs(m.고객변경이력)
			ordered no_merge(m) use_hash(m) use_hash(h) */
		c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c
	, (select 고객번호, max(변경일시) 최종변경일시
	   from 고객변경이력
	   where 변경일시 >= trunc(add_months(sysdate, -12), 'mm')
	   and 변경일시 < trunc(sysdate, 'mm')
 	   group by 고객번호
	) m
    , 고객변경이력 h
where c.고객구분코드 = 'A001'
and m.고객번호 = c.고객번호
and h.고객번호 = m.고객번호
and h.변경일시 = m.최종변경일시
```

#### 윈도우함수 이용하기
- 테이블을 두 번 읽는 비효율을 없앨 수 있다.

```sql
insert into 고객_임시
select 고객번호, 고객명, 전화번호, 주소, 상태코드, 변경일시
from (
	select /*+ full(c) full(h) leading(c) use_hash(h) */
		c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
		, rank() over (partition by h.고객번호 order by h.변경일시 desc) ㅜㅐ
	from 고객 c, 고객변경이력 h
	where c.고객구분코드 = 'A001'
    and h.변경일시 >= trunc(add_months(sysdate, -12), 'mm')
	and h.변경일시 < trunc(sysdate, 'mm')
	and h.고객번호 = c.고객번호
)
where no = 1
```

### 3.1.4 인덱스 컬럼 추가

```sql
select 렌탈관리번호, 고객명, 서비스관리번호, 서비스번호, 예약접수일시
	   , 방문국가코드1, 방문국가코드2, 방문국가코드3, 로밍승인번호, 자동로밍여부
from 로밍렌탈
where 서비스번호 like '010%'
and 사용여부 = 'Y'
```

```
| Call | Count | CPU Time | Elapsed Time | Disk | Query | Current | Rows |
|---|---|---|---|---|---|---|---|
| Parse | 1 | 0.010 | 0.012 | 0 | 0 | 0 | 0 |
| Execute | 1 | 0.000 | 0.000 | 0 | 0 | 0 | 0 |
| Fetch | 78 | 10.150 | 49.199 | 27830 | 266968 | 0 | 1909 |
| Total | 80 | 10.160 | 49.211 | 27830 | 266968 | 0 | 1909 |

Rows     Row Source Operation
-------  -----------------------------------------------------------------------
   1909  TABLE ACCESS BY INDEX ROWID 로밍렌탈 (cr=266968 pr=27830 pw=0 time=... )
 266476   INDEX RANGE SCAN 로밍렌탈_N2 (cr=1011 pr=900 pw=0 time=1893462 us)
```

> 팁 : cr은 Consistent Read(논리적 읽기), pr은 Physical Read(물리적 디스크 읽기)를 의미합니다.

1. 블록 I/O 계산
	- 전체 논리적 I/O (Query): 총 266,968 블록 I/O
	- 인덱스 스캔 I/O : INDEX RANGE SCAN 단계에서 발생한 1,011 블록 I/O
		- 블록 I/O는 각 오퍼레이션 우측 괄호에 있는 cr항목을 통해 확인 가능하다.
	- 테이블 랜덤 액세스 I/O : 전체 I/O - 인덱스 I/O
		- 266,968 - 1,011 = 265,957 블록 I/O
		- 전체 I/O의 **99.6%** 가 테이블 랜덤 액세스에서 발생

2. 성능 문제점 (Efficiency)
	- 비효율적인 스캔 : 인덱스에서 266,476건을 읽었으나, 최종 결과(Rows)는 1,909건에 불과합니다.
		- 인덱스 스캔을 통해 얻은 건수는 인덱스 스캔 단계 왼쪽에 나타난 Rows 숫자를 보면 된다.
		- 즉, 인덱스를 거쳐 테이블을 방문한 횟수가 '266,476'번인 것이다.
	- 원인 : '서비스번호' 단일 컬럼으로 구성된 인덱스를 사용했기 때문에, 조건에 맞지 않는 데이터까지 과도하게 테이블을 방문(Random Access)하고 있습니다.
	- 결과 : 총 소요 시간 49초 중 대부분이 이 랜덤 액세스 과정에서 소모되었습니다.

3. 튜닝 방안 

```
| Call | Count | CPU Time | Elapsed Time | Disk | Query | Current | Rows |
|---|---|---|---|---|---|---|---|
| Parse | 1 | 0.000 | 0.001 | 0 | 0 | 0 | 0 |
| Execute | 1 | 0.000 | 0.000 | 0 | 0 | 0 | 0 |
| Fetch | 78 | 0.140 | 0.154 | 0 | 2902 | 0 | 1909 |
| Total | 80 | 0.140 | 0.156 | 0 | 2902 | 0 | 1909 |

Rows     Row Source Operation
-------  -----------------------------------------------------------------------
   1909  TABLE ACCESS BY INDEX ROWID 로밍렌탈 (cr=2902 pr=0 pw=0 time=... )
   1909   INDEX RANGE SCAN 로밍렌탈_N2 (cr=1001 pr=0 pw=0 time=198557 us)
```

- '로밍렌탈_N2' 인덱스에 '사용여부' 컬럼을 추가하면 된다. 
- 인덱스를 거쳐 테이블에 1909번 방문했고, 총 블록 I/O도 2902로 줄었다.


### 3.1.5 인덱스만 읽고 처리

**"어차피 테이블에 가봤자 데이터가 없을 수도 있고 가는데 시간도 걸리니, 필요한 걸 인덱스에 다 때려 넣자!"** 는 전략입니다.

| 구분 | Covered Index (일반적인 복합 인덱스) | Include Index |
|---|---|---|
| 핵심 목적 | 테이블 방문 제거 + 검색 효율 강화 | 테이블 방문 제거 (정렬 오버헤드 감소) |
| 정렬 여부 | 인덱스 내 모든 컬럼이 정렬됨 | 키 컬럼만 정렬, Include 컬럼은 값만 저장 |
| 인덱스 크기 | 컬럼이 추가될수록 정렬 구조가 커짐 | 정렬에 참여하지 않아 상대적으로 가벼움 |

#### Coverd Index

- 커버링 인덱스는 쿼리 수행에 필요한 모든 컬럼을 인덱스가 다 가지고 있는 상태를 말합니다.

- SQL문에 등장하는 컬럼(SELECT절, WHERE절, ORDER BY절 등)이 전부 인덱스 구성 컬럼에 포함되어 있으면, 오라클은 굳이 테이블을 찾아가지(TABLE ACCESS) 않습니다. 
	- 인덱스만 읽고도 결과를 다 만들 수 있기 때문이죠.

- 장점: 테이블 방문이 0번이 됩니다. I/O가 획기적으로 줄어듭니다.
- 단점: 필요한 컬럼이 많아질수록 인덱스 크기가 커지고, 데이터 입력/수정(DML) 시 인덱스 관리 비용이 증가합니다.

#### Include Index

- 이건 주로 SQL Server(MSSQL)나 PostgreSQL에서 사용하는 용어인데, 개념은 아주 유용합니다. 
- 오라클에서는 유사하게 인덱스 구성을 변경해서 처리합니다.
- 인덱스의 '정렬 키(Key)'에는 포함시키지 않지만, 데이터만 인덱스의 리프 페이지(Leaf Page)에 저장해두는 방식입니다.
- 차이점
	- 키 컬럼 : 이 컬럼으로 데이터를 정렬함. (검색 조건에 사용)
	- Include 컬럼 : 정렬은 안 하지만 값만 들고 있음. (SELECT절에 사용)

- 장점 : 인덱스의 정렬 구조(B-Tree)를 복잡하게 만들지 않으면서(인덱스 레벨이 깊어지는 걸 방지), 테이블 방문은 효과적으로 막아줍니다.

### 3.1.6 인덱스 구조 테이블

- IOT(Index Organized Table, 인덱스 구조 테이블)은 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성하는 것이다. 

- ROWID를 갖지 않고, 그 자리에 테이블 데이터를 갖는다. 인덱스 리프블록이 곧 데이터블록인 셈이다. 

- IOT는 정렬된 상태로 모여 있으므로, 클러스터링 팩터가 좋다. 
    - between이나 부등호 조건으로 넒은 범위를 읽을 떄 유리하다. 

### 3.1.7 클러스터 테이블

- 인덱스 클러스터와 해시 클러스터 두 가지가 있다. 

#### 인덱스 클러스터 테이블(= 클러스터 테이블)

- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다. 
	
- 한 블록에 안담길 때는, 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 
- 여러 테이블의 레코드를 같은 블록에 저장할 수도 있다. (= 다중 테이블 클러스터)
- 하지만 IOT나 클러스터형 인덱스와 달리, 정렬은 안되어 있다. 

#### 헷갈리는 개념 및 용어

| 구분 | 클러스터 인덱스 (Clustered Index) | 인덱스 클러스터 테이블 (Index Cluster) |
|---|---|---|
| 대상 | 단일 테이블의 정렬 방식 | 여러 테이블 간의 물리적 결합 |
| 구조 | 인덱스 끝에 데이터가 붙어 있음 | 클러스터 키가 같은 행들을 같은 블록에 저장 |
| 목적 | 단일 테이블 내 범위 검색 최적화 | Join 성능 극대화 (미리 Join해둔 효과) |
| 특징 | 별도의 클러스터 오브젝트가 없음 | 반드시 CREATE CLUSTER로 클러스터를 먼저 생성 |


1. 클러스터 (Cluster): 아파트 단지 부지입니다. (여러 집이 모여 살 땅)

2. 클러스터 테이블 (Cluster Table): 그 땅에 들어설 **실제 집(데이터)** 입니다.
	- 개념 : 여러 개의 테이블을 물리적으로 한곳에 모아 저장하는 방식입니다.
	- 핵심 : **"공통 컬럼(Cluster Key)을 가진 데이터를 서로 다른 테이블이라도 같은 블록에 모아두는 것"** 입니다.
	- '아빠', '엄마', '나'라는 데이터(테이블)가 각기 다르지만, '우리 집'이라는 클러스터 키를 기준으로 한 페이지(블록)에 같이 모여 있는 것과 같습니다.
		
3. 클러스터 인덱스 (Cluster Index): 단지 입구에 있는 호수별 위치 안내도입니다.
	- 개념 : 테이블당 단 하나만 존재할 수 있는 '정렬된 인덱스'입니다.
	- 핵심 : **"인덱스의 리프 페이지가 곧 데이터 페이지"**입니다. 즉, 인덱스 자체가 테이블 데이터입니다.
	- 자체로 "국어사전" 그 자체입니다. 'ㄱ'을 찾으면 그 자리에 바로 단어 뜻이 적혀 있는 것과 같습니다.

#### 순서 
> '클러스터 생성 → 클러스터 인덱스 생성 → 테이블 생성 및 데이터 입력' 

- 클러스터 인덱스는 클러스터 테이블 내에서 데이터가 저장될 실제 물리적 위치를 찾아주는 역할을 하기 때문에, 데이터(Table Row)를 넣기 전에 반드시 인덱스부터 정의되어 있어야 합니다.

1. `CREATE CLUSTER` (단지 부지 조성)
	- **'클러스터 테이블'** 을 구성하려면, **'클러스터'** 를 먼저 생성해야 합니다.
	- 먼저 "여기는 '고객번호'가 같은 데이터들끼리 모여 살 공간이야!"라고 선포하며 땅을 닦아야 하기 때문입니다.
	- 하지만 아직 이 땅은 텅 비어 있고, **어떤 번호가 어느 블록에 들어가야 할지 결정하는 '기준'** 이 없는 상태입니다.

2. `CREATE INDEX ... ON CLUSTER` (위치 안내도 설치)
	- **'클러스터'** 에 테이블을 담기 전, 반드시 **'클러스터 인덱스'** 를 정의해야 한다.
	- 데이터를 넣기 전에 '안내도(클러스터 인덱스)'를 먼저 만들어야 합니다.
		- 데이터가 들어올 때, "어느 블록(방)에 가서 저장되어야 하지?"를 결정하려면 이 안내도가 있어야 하기 때문입니다.
	- 만약 안내도가 없다면? 
		- 데이터가 들어와도 어디에 저장될지 몰라서 길을 잃게 됩니다. 
		- 그래서 오라클은 '클러스터 인덱스' 없이는 데이터를 아예 못 넣게 막아두었습니다.

3. `CREATE TABLE ... CLUSTER` (입주)
	- 이제 실제 테이블을 생성하고 데이터를 넣습니다. 
	- 데이터가 들어오면 미리 만들어둔 클러스터 인덱스를 보고, "아, 너는 10번 고객이니까 저쪽 블록으로 가!"라고 위치를 지정받아 저장됩니다.

#### '클러스터 인덱스' vs 일반 인덱스 차이점

| 구분 | 일반 테이블의 인덱스 | 클러스터 인덱스 |
|---|---|---|
| 존재 목적 | 데이터 찾기 전용 | 데이터 위치 지정 + 찾기 |
| 생성 시점 | 데이터 넣고 나서 만들어도 됨 | 데이터 넣기 전에 반드시 필요 |
| 데이터 관계 | 인덱스와 데이터는 별개 공간 | 인덱스가 가리키는 곳에 데이터가 모여 있음 |
| 누락 시 | 검색만 느려짐 | 데이터 입력(Insert) 자체가 불가능 |


- B*Tree 인덱스 구조를 사용하지만, 첫 번째 데이터 블록을 가리킨다. 
- 그래서 테이블 레코드와 1:M 구조를 갖는다. 
- 즉 랜덤 액세스가 값 하나 당 한 번씩밖에 발생하지 않기 때문에, 비효율이 없다.


#### 해시 클러스터 

- 해시 클러스터는 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다. 