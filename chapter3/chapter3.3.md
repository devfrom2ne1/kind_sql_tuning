# 3. 인덱스 튜닝

## 3.3 인덱스 스캔 효율화

### 3.3.1 인덱스 탐색

![image](https://github.com/user-attachments/assets/911af07e-8884-49d4-b338-81ad617fa6f3)

![image](https://github.com/user-attachments/assets/6a8e8590-5d04-45da-ba5e-a7b3823bb444)

![image](https://github.com/user-attachments/assets/d24594f1-8043-42c2-9c78-794d7370392a)

![image](https://github.com/user-attachments/assets/047bba9c-9902-473f-9cf5-17d3a76bc3c1)

![image](https://github.com/user-attachments/assets/5a8d533e-59ba-473b-950e-612cce70e6bf)

![image](https://github.com/user-attachments/assets/ffa2b957-cd15-4733-bb89-3b600c5b68da)

#### 인덱스 스캔 과정에서 비효율이 발생하는 이유
1. 인덱스 선행 컬럼이 조건절에 없을 때 
2. 인덱스 선행 컬럼이 '=' 조건이 아닐 때

### 3.3.2 인덱스 스캔 효율성

#### SQL 트레이스 읽는 법
- 실행 계획은 보통 안쪽(들여쓰기 된 곳)부터 읽습니다.
- `cr` (Consistent Read) : 메모리에서 데이터를 읽은 횟수입니다. (낮을수록 Good)
- `pr` (Physical Read) : 메모리에 없어서 **하드디스크(Disk)** 에서 직접 읽어온 횟수입니다. 
- `time` : 총 걸린 시간입니다. 여기서는 약 22ms (0.022초) 정도 소요되었습니다.

```
Rows	Row Source Operation
------	-------------------------------------------
10	TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
10	 INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=146 time=22328 us)
```

> "BIG_TABLE_IDX라는 인덱스(찾아보기)에서 조건에 맞는 10개를 먼저 찾은 뒤, 그 10개의 상세 정보를 실제 BIG_TABLE(원본 테이블)에 가서 꺼내왔다."


#### 1. 2행 : `INDEX RANGE SCAN BIG_TABLE_IDX`
- 인덱스(BIG_TABLE_IDX)의 일정 범위를 훑었다는 뜻입니다.
- `Rows (10)`
	- 인덱스에서 조건에 맞는 데이터 10건을 찾아냈습니다.
- `비용(cr=7463)`
	- 10건을 찾기 위해 7,463번의 블록(데이터 단위) 읽기가 발생했습니다. 
	- 10건 치고는 꽤 많이 읽은 편입니다.

#### 2. 1행 : `TABLE ACCESS BY INDEX ROWID BIG_TABLE`
- 인덱스에서 알아낸 **ROWID(데이터의 물리적 주소)** 를 가지고 실제 테이블에 가서 나머지 컬럼 정보를 가져왔다는 뜻입니다.
- `Rows (10)`
	- 최종적으로 10행의 결과가 나왔습니다.
 - `비용(cr=7471)`
	- 인덱스 읽기(7463) + 테이블 직접 읽기(8)를 합쳐 총 7,471번의 읽기가 발생했습니다.

#### 3. 결론
- 결과물은 딱 10건인데, 이를 찾기 위해 읽은 블록 수(cr=7471)가 상당히 많습니다.
	- 원인 1 : 인덱스 범위가 너무 넓게 잡혀서 쓸데없는 데이터를 많이 걸러냈을 수 있습니다.	
	- 원인 2 : 인덱스 자체가 효율적이지 않게 설계되었을 가능성이 있습니다.

### 3.3.3 액세스 조건과 필터 조건

![image](https://github.com/user-attachments/assets/64db020f-66ad-4c3d-8d9b-a97713cad13c)

```
 * 테이블 : 도서관 전체 책장
 * 인덱스 : [장르 + 저자 + 출판일] 순으로 정렬된 목록집
 * 찾는 조건 : 
  1) 장르 = '소설' 
  2) 저자 = '김철수'  
  3) 출판일 > '2023년' 
  4) 내용에 '강아지'가 포함됨
```

| 구분 | 어디서 검사하나? | 특징 | 성능 영향 |
|---|---|---|---|
| 액세스 조건 | 인덱스 (수직 탐색) | 스캔의 시작/종료점 결정 | 가장 중요 (CR 감소) |
| 인덱스 필터 | 인덱스 (수평 스캔) | 테이블로 갈지 말지 결정 | 테이블 방문 횟수 감소 |
| 테이블 필터 | 실제 테이블 블록 | 최종 결과에 넣을지 결정 | 여기서 많이 걸러지면 비효율 |

#### 1. 인덱스 액세스 조건

- 인덱스 스캔 범위를 결정하는 조건절이다. 
- 수직적 탐색을 통해 '시작점'을 결정할 때와, 
- 인덱스 리프 블록을 스캔하다가 '종료점'을 결정하는데 영향을 미친다. 
- 리프 블록을 덜 읽게 해준다. (CR 감소)

- "인덱스에서 어디부터 어디까지 읽을지 딱 정해주는 조건"
	- 설명 : 인덱스의 첫 번째, 두 번째 컬럼처럼 정렬 순서에 직접 관여하여 스캔의 시작과 끝을 결정합니다.
	- 목록집이 '장르'순으로 되어 있으므로, `장르 = '소설'` 조건을 보고 소설 섹션이 시작되는 페이지로 바로 이동합니다. 
	- 그다음 `저자 = '김철수'` 를 보고 김철수 저자가 끝나는 지점까지만 읽기로 합니다.
	- 이 조건이 좋을수록 읽어야 할 리프 블록(목록 페이지) 수가 획기적으로 줄어듭니다.

#### 2. 인덱스 필터 조건

- 테이블로 액세스 할지 말지 결정하는 조건
- 테이블을 덜 가게 해준다. (Table Access By Index Rowid 횟수 감소)

- "인덱스엔 적혀 있는데, 범위를 줄여주지는 못하고 하나씩 대조해봐야 하는 조건"
	- 설명 : 인덱스 구성 컬럼이긴 하지만, 정렬 순서상 범위를 좁히지는 못하고 목록을 읽으면서 "맞나? 아니네" 하며 걸러내는 역할입니다.
	- '소설+김철수' 구간을 읽으면서 `출판일` 을 하나씩 확인하며 걸러냅니다.
	- 테이블(본문)로 가기 전에 목록에서 미리 걸러내기 때문에, 테이블 액세스 횟수를 줄여줍니다.

#### 3. 테이블 필터 조건

- 인덱스를 이용하든, 테이블을 Full Scan 하든, 테이블 액세스 단계에서 처리되는 조건절은 모두 테이블 필터 조건이다. 
- 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다. 

- "인덱스엔 정보가 없어서, 실제 테이블을 봐야만 알 수 있는 조건"
	- 설명 : 인덱스에 없는 컬럼이 조건절에 있을 때입니다. 무조건 실제 테이블 블록에 접근(Table Access)한 뒤에야 확인할 수 있습니다.
	- `내용에 '강아지'가 포함` 됨 조건입니다. 
	- 인덱스에는 내용 컬럼이 없습니다. 
	- 결국 '소설+김철수+2023년이후'인 책들을 서가에서 직접 꺼내서(Table Access) 내용을 읽어보고 강아지가 없으면 버립니다.
	- 효과 : 이 조건에서 많이 걸러진다면, **"불필요하게 책을 서가에서 너무 많이 꺼냈다"** 는 뜻이므로 성능상 가장 좋지 않습니다.


#### 옵티마이저의 비용 계산 원리 

```
비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
```

1. `인덱스 수직적 탐색 비용`
	- 인덱스 루트와 브랜치 레벨에서 읽는 블록 수

2. `인덱스 수평적 탐색 비용`
	- 인덱스 리프 블록을 스캔하는 과정에서 읽는 블록 수
3. `테이블 랜덤 액세스 비용`
	- 테이블 액세스 과정에 읽는 블록 수

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

> [!NOTE]
> '=' 조건이라면 모두 모여 있지만, 비교 연산자가 나오는 순간부터 데이터는 연속해서 모여 있지 않고 흩어져 있다. 

| | 인덱스 액세스 조건 | 인덱스 필터 조건 |
|---|---|---|
|조건절 1 |C1, C2, C3, C4| |
|조건절 2 |C1, C2, C3, C4| |
|조건절 3 |C1, C2, C3|C4|
|조건절 4 |C1, C2|C3, C4|
|조건절 5 |C1|C2, C3, C4|

```sql
<조건절 1>
where C1 = 1
and   C2 = 'A'
and   C3 = '나'
and   C4 = 'a'
```

```sql
<조건절 2>
where C1 = 1
and   C2 = 'A'
and   C3 = '나'
and   C4 >= 'a'
```

```sql
<조건절 3>
where C1 = 1
and   C2 = 'A'
and   C3 between '가' and '다'
and   C4 = 'a'
```

```sql
<조건절 4>
where C1 = 1
and   C2 <= 'B'
and   C3 = '나'
and   C4 between 'a' and 'b'
```

```sql
<조건절 5>
where C1 between 1 and 3
and   C2 = 'A'
and   C3 = '나'
and   C4 = 'a'
```

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

> [!NOTE]
> 인덱스 컬럼 중 일부가 조건절에 없거나 등치조건이 아니어도, 뒤쪽 컬럼이면 비효율이 없다. 

```sql
where 아파트시세코드 = 'A0102'
and   평형 = '59'
and   평형타입 = 'A'
and   인터넷매물 between '1' and '3'
order by 입력일 desc
```

- 인덱스 1 : [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] ➔ 비효율 없음
- 인덱스 2 : [인터넷매물 + 아파트시세코드 + 평형 + 평형타입] ➔ 비효율 있음

### 3.3.6 BETWEEN을 IN-List로 전환

> [!NOTE]
> BETWEEN을 IN-List로 전환하면, 큰 효과를 얻는 경우도 있다.

```sql
where 아파트시세코드 = 'A0102'
and   평형 = '59'
and   평형타입 = 'A'
and   인터넷매물 in ('1', '2', '3')
order by 입력일 desc
```

#### BETWEEN을 IN-List로 전환하면...
1. In-List개수만큼 UNION ALL 브랜치가 생성된다.
2. 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색한다( **수직적 탐색** 이 발생)
- IN-List 항목 개수가 늘어날 수 있다면, NL방식의 조인문이나 서브쿼리로 구현하면 된다.

#### BETWEEN을 IN-List로 전환할 때 유의할 점
1. IN-List 갯수가 너무 많으면 비효율적이다.
	- 수직적 탐색이 너무 많이 발생하기 때문이다. 
	- 특히, 루트에서 브랜치 블록까지 Depth가 깊으면 더 비효율적이다.
	- 그래서 수직적 탐색 비용을 따져보고 변환해야 한다.

2. 인덱스 스캔 과정에서 선택되는 레코드들이 멀리 떨어져 있을 때만 유용하다. 
	- 데이터 분포를 따져보고 변환해야 한다. 

### 3.3.7 Index Skip Scan 활용

> [!NOTE]
> 선두컬럼이 	BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.

```sql
create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월, 판매구분);
```

![image](https://github.com/user-attachments/assets/7b294422-28ca-412f-87cf-8752d59e75b4)

| 구분 | between | IN-List | Skip Scan |
|---|---|---|---|
| 블록 I/O( = `cr`) | 3,090 | 314 | 300 |

#### between

```sql
select /*+ index(t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and   판매월 between '201801' and '201812'
```

#### IN-List

```sql
select /*+ index(t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and   판매월 in ('201801' ,'201802' ,'201803' , .....  ,'201812')
```

#### Index Skip Scan

```sql
select /*+ INDEX_SS(t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and   판매월 between '201801' and '201812'
```

### 3.3.8 IN 조건은 '='인가

> [!WARNING]
> 인덱스 스캔을 IN-List Iterator 방식으로 유도하는 것이 무조건 성능향상에 도움이 되는 것은 아니다. 


#### IDX1 : [상품ID + 고객번호]

```sql
select * 
from 고객별가입상품
where 고객번호 = :cust_no
and   상품ID in ('NH00037', 'NH00041', 'NH00050')
```

![image](https://github.com/user-attachments/assets/d48d9284-e01d-4651-86a7-1a38cd824744)

1. In-List Iterator 방식으로 푼다면?
	- 수직적 탐색 : 3번
		- 하나의 상품 정보를 찾기 위해 3개의 블록(루트1 + 브랜치1 + 리프1)
	- 블록 I/O : 9개
		- 조건에 상품ID가 3개(NH00037, NH00041, NH00050) 있으므로, 총 3개 상품 × 3개 블록 = 9개 블록을 읽게 됨
	- 지금은 상품ID 조건절이 IN-List Iterator 방식으로 풀리는 것이 효율적이다. 

2. In-List Iterator 방식으로 풀지 않으면?
	- 필터조건 : 상품ID
	- 테이블 전체 or 인덱스 전체 스캔하면서 필터링 해야하므로 비효율적이다.


#### IDX2 : [고객번호 + 상품ID]

```sql
select * 
from 고객별가입상품
where 고객번호 = :cust_no
and   상품ID in ('NH00037', 'NH00041', 'NH00050')
```

![image](https://github.com/user-attachments/assets/698ff03b-8ecd-4515-b6b1-ffa9a8c1f54d)

1. In-List Iterator 방식으로 푼다면?
	- 수직적 탐색 : 3번
		- 하나의 상품 정보를 찾기 위해 3개의 블록(루트1 + 브랜치1 + 리프1)
	- 블록 I/O : 9개
		- 조건에 상품ID가 3개(NH00037, NH00041, NH00050) 있으므로, 총 3개 상품 × 3개 블록 = 9개 블록을 읽게 됨

2. In-List Iterator 방식으로 풀지 않으면?
	- `고객번호 = 1234` 인 레코드를 모두 스캔한다. 
	- 같은 고객은 1~2개의 연속된 블록에 모여 있으므로, `블록 I/O = 3~4번` 이 된다.
	- 이때는 '필터' 방식으로 처리되는 게 더 효율적이다.

#### IN_List를 액세스 조건 또는 필터 조건으로 유인하는 방법

1. `NUM_INDEX_KEYS` 힌트

```sql
select /*+ num_index_keys(a 고객가입별상품_x1 1) */ *
from 고객별가입상품 a
where 고객번호 = :cust_no
and   상품ID in ('NH00037', 'NH00041', 'NH00050')
```

- num_index_keys(테이블명 인덱스명 인덱스컬럼)
	- 힌트의 세 번째 인자 1은 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미이다. 

- 고객가입별상품_x1 : [고객번호 + 상품ID]
	- `num_index_keys(a 고객가입별상품_x1 1)`
		- 힌트의 선두컬럼인 '고객번호'만 인덱스 액세스 조건으로 활용되고, 
		- '상품ID'는 필터조건이 된다.

	- `num_index_keys(a 고객가입별상품_x1 2)`
		- '고객번호'와 '상품ID' 모두 인덱스 액세스 조건으로 사용된다.
		- 이때는 상품ID가 IN-List Iterator 방식으로 풀린다. 

2. 인덱스 컬럼을 가공하는 방식

```sql
select *
from 고객별가입상품 a
where 고객번호 = :cust_no
and   RTRIM(상품ID) in ('NH00037', 'NH00041', 'NH00050')

select *
from 고객별가입상품 a
where 고객번호 = :cust_no
and   상품ID || '' in ('NH00037', 'NH00041', 'NH00050')
```

- 힌트 대신 인덱스 컬럼을 가공해도 된다. 
- 그러면 '고객번호'만 인덱스 액세스 조건으로 활용되고,
- '상품ID'는 필터조건이 된다.

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

- LIKE보다 BETWEEN을 사용하는 것이 더 낫다.

```sql
<조건절 1>
where 판매월 BETWEEN '201901' and '201912'
and 판매구분 = 'B'

<조건절 2>
where 판매월 LIKE '2019%'
and 판매구분 = 'B'
```


### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### 3.3.12 함수호출부 해소를 위한 인덱스 구성