# 3. 인덱스 튜닝

## 3.3 인덱스 스캔 효율화

### 3.3.1 인덱스 탐색

💡 책 173~179p : 탐색과정을 이해할 수 있는 그림!

### 3.3.2 인덱스 스캔 효율성

- 인덱스 선행 컬럼이 조건절에 없거나, '=' 조건이 아니면 인덱스 스캔 과정에서 비효율이 발생한다!
    - 선두 컬럼 : 맨 앞쪽 컬럼
    - 선행 컬럼 : 상대적으로 앞쪽에 놓인 컬럼

### 3.3.3 액세스 조건과 필터 조건

#### 인덱스 액세스 조건

- 인덱스 스캔 범위를 결정하는 조건절이다. 
- 수직적 탐색을 통해 '시작점'을 결정할 때와, 인덱스 리프 블록을 스캔하다가 '종료점'을 결정하는데 영향을 미친다. 

#### 인덱스 필터 조건

- 테이블로 액세스 할지 말지 결정하는 조건

#### 테이블 필터 조건

- 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정하는 조건


### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- '=' 조건이라면 모두 모여 있지만, 비교 연산자가 나오는 순간부터 데이터는 연속해서 모여 있지 않고 흩어져 있다. 

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 컬럼 중 일부가 조건절에 없거나 등치조건이 아니어도, 뒤쪽 컬럼이면 비효율이 없다. 

### 3.3.6 BETWEEN을 IN-List로 전환

- BETWEEN을 IN-List로 전환하면, 큰 효과를 얻는 경우도 있다. 
    - UNION ALL 브랜치가 생성되고, 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하기 떄문이다. 

- 전환할 때 유의할 점
    - IN-List 갯수가 너무 많으면 비효율적이다. 
    - 레코드가 멀리 떨어져 있을 때만 유용하다. 

### 3.3.7 Index Skip Scan 활용

- Index Skip Scan 힌트 : `/*+ INDEX_SS(t 월별고객별판매집계_IDX2) */`
- Ex. 2018년 1월 ~ 12월까지의 'A'상품과 'B'상품의 판매데이터
    - 데이터 갯수 : A=10만개, B=110만개
    - `create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월 , 판매구분)`
    - 이 인덱스를 사용할 경우, 쓸데없이 월별로 'B'상품 블록을 전부 탐색해야함!
    - 이 때 Index Skip Scan 을 활용하면, 탐색블록이 확 줄어든다~

### 3.3.8 IN 조건은 '='인가

- 만약 IN 조건이 IN-List Iterator 방식으로 풀린다면 IN 조건은 '='이라고 볼 수 있다!

- 하지만, 그렇지 않다면 단순 필터 조건이다.

- IN_List를 액세스 조건 또는 필터 조건으로 유인하는 방법
    1. NUM_INDEX_KEYS 힌트
        - `select /*+ num_index_keys(a 고객가입별상품_x1 1) */` : 힌트의 세 번째 인자 1은 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미이다. 
    2. 인덱스 컬럼을 가공해도 된다. `where RTRIM(상품ID) in ('NH001', 'NH002', 'NH003')`

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

- LIKE보다 BETWEEN을 사용하는 것이 더 낫다.

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### 3.3.12 함수호출부 해소를 위한 인덱스 구성