# 3. 인덱스 튜닝

## 3.3 인덱스 스캔 효율화

### 3.3.1 인덱스 탐색

![image](https://github.com/user-attachments/assets/911af07e-8884-49d4-b338-81ad617fa6f3)

![image](https://github.com/user-attachments/assets/6a8e8590-5d04-45da-ba5e-a7b3823bb444)

![image](https://github.com/user-attachments/assets/d24594f1-8043-42c2-9c78-794d7370392a)

![image](https://github.com/user-attachments/assets/047bba9c-9902-473f-9cf5-17d3a76bc3c1)

![image](https://github.com/user-attachments/assets/5a8d533e-59ba-473b-950e-612cce70e6bf)

![image](https://github.com/user-attachments/assets/ffa2b957-cd15-4733-bb89-3b600c5b68da)

### 3.3.2 인덱스 스캔 효율성

#### 인덱스 스캔 과정에서 비효율이 발생하는 이유
1. 인덱스 선행 컬럼이 조건절에 없을 때 
2. 인덱스 선행 컬럼이 '=' 조건이 아닐 때

#### 인덱스 스캔 효율성 측정 방식(SQL 트레이스)

```
Rows	Row Source Operation
------	-------------------------------------------
10	TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
10	 INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=146 time=22328 us)
```

> "BIG_TABLE_IDX라는 인덱스(찾아보기)에서 조건에 맞는 10개를 먼저 찾은 뒤, 그 10개의 상세 정보를 실제 BIG_TABLE(원본 테이블)에 가서 꺼내왔다."

- SQL 트레이스 읽는 법
	- 실행 계획은 보통 안쪽(들여쓰기 된 곳)부터 읽습니다.
	- `cr` (Consistent Read) : 메모리에서 데이터를 읽은 횟수입니다. (낮을수록 Good)
	- `pr` (Physical Read) : 메모리에 없어서 **하드디스크(Disk)** 에서 직접 읽어온 횟수입니다. 
	- `time` : 총 걸린 시간입니다. 여기서는 약 22ms (0.022초) 정도 소요되었습니다.

1. 2행 : `INDEX RANGE SCAN BIG_TABLE_IDX`
	- 인덱스(BIG_TABLE_IDX)의 일정 범위를 훑었다는 뜻입니다.
	- `Rows (10)`
		- 인덱스에서 조건에 맞는 데이터 10건을 찾아냈습니다.
	- `비용(cr=7463)`
		- 10건을 찾기 위해 7,463번의 블록(데이터 단위) 읽기가 발생했습니다. 
		- 10건 치고는 꽤 많이 읽은 편입니다.

2. 1행 : `TABLE ACCESS BY INDEX ROWID BIG_TABLE`
	- 인덱스에서 알아낸 **ROWID(데이터의 물리적 주소)** 를 가지고 실제 테이블에 가서 나머지 컬럼 정보를 가져왔다는 뜻입니다.
	- `Rows (10)`
		- 최종적으로 10행의 결과가 나왔습니다.
 	- `비용(cr=7471)`
		- 인덱스 읽기(7463) + 테이블 직접 읽기(8)를 합쳐 총 7,471번의 읽기가 발생했습니다.

3. 결론
	- 결과물은 딱 10건인데, 이를 찾기 위해 읽은 블록 수(cr=7471)가 상당히 많습니다.
		- 원인 1 : 인덱스 범위가 너무 넓게 잡혀서 쓸데없는 데이터를 많이 걸러냈을 수 있습니다.	
		- 원인 2 : 인덱스 자체가 효율적이지 않게 설계되었을 가능성이 있습니다.

### 3.3.3 액세스 조건과 필터 조건

![image](https://github.com/user-attachments/assets/64db020f-66ad-4c3d-8d9b-a97713cad13c)

#### 1. 인덱스 액세스 조건

- 인덱스 스캔 범위를 결정하는 조건절이다. 
- 수직적 탐색을 통해 '시작점'을 결정할 때와, 인덱스 리프 블록을 스캔하다가 '종료점'을 결정하는데 영향을 미친다. 

#### 2. 인덱스 필터 조건

- 테이블로 액세스 할지 말지 결정하는 조건

#### 3. 테이블 필터 조건

- 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정하는 조건


### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- '=' 조건이라면 모두 모여 있지만, 비교 연산자가 나오는 순간부터 데이터는 연속해서 모여 있지 않고 흩어져 있다. 

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 컬럼 중 일부가 조건절에 없거나 등치조건이 아니어도, 뒤쪽 컬럼이면 비효율이 없다. 

### 3.3.6 BETWEEN을 IN-List로 전환

- BETWEEN을 IN-List로 전환하면, 큰 효과를 얻는 경우도 있다. 
    - UNION ALL 브랜치가 생성되고, 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하기 떄문이다. 

- 전환할 때 유의할 점
    - IN-List 갯수가 너무 많으면 비효율적이다. 
    - 레코드가 멀리 떨어져 있을 때만 유용하다. 

### 3.3.7 Index Skip Scan 활용

- Index Skip Scan 힌트 : `/*+ INDEX_SS(t 월별고객별판매집계_IDX2) */`
- Ex. 2018년 1월 ~ 12월까지의 'A'상품과 'B'상품의 판매데이터
    - 데이터 갯수 : A=10만개, B=110만개
    - `create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월 , 판매구분)`
    - 이 인덱스를 사용할 경우, 쓸데없이 월별로 'B'상품 블록을 전부 탐색해야함!
    - 이 때 Index Skip Scan 을 활용하면, 탐색블록이 확 줄어든다~

### 3.3.8 IN 조건은 '='인가

- 만약 IN 조건이 IN-List Iterator 방식으로 풀린다면 IN 조건은 '='이라고 볼 수 있다!

- 하지만, 그렇지 않다면 단순 필터 조건이다.

- IN_List를 액세스 조건 또는 필터 조건으로 유인하는 방법
    1. NUM_INDEX_KEYS 힌트
        - `select /*+ num_index_keys(a 고객가입별상품_x1 1) */` : 힌트의 세 번째 인자 1은 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미이다. 
    2. 인덱스 컬럼을 가공해도 된다. `where RTRIM(상품ID) in ('NH001', 'NH002', 'NH003')`

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

- LIKE보다 BETWEEN을 사용하는 것이 더 낫다.

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### 3.3.12 함수호출부 해소를 위한 인덱스 구성