# 3. 인덱스 튜닝

## 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리

#### '부분범위 처리'란?
- '부분범위 처리'는 테이블 랜덤 액세스로 인한 인덱스 손익분기점 한계를 극복하는 방법이다.
- '부분범위 처리'를 사용하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼 수 있다..
- 즉, '부분범위 처리'란 바로 전체 쿼리 결과집합을 연속적으로 전송하지 않고, 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 방식이다. 
- 일정량씩 데이터를 전송하는 단위를 'Array Size'라고 한다. 

#### 1억 건짜리 테이블 부분범위 처리 과정 
> 부분범위 처르를 활용하면 DBMS가 데이터를 모두 읽어 한 번에 전송하지 않고 먼저 읽는 데이터부터 일정량을 전송하기 멈추기 때문에 결과를 빨리 출력할 수 있다. 

1. DBMS는 먼저 읽은 데이터부터 일정량을 전송한다. 
2. 일정량의 데이터를 전송하고 나면, DB서버 프로세스는 CPU를 OS에 반환하고 대기큐에서 잠을 잔다. 
3. 그리고 다음 Fetch Call을 받으면 대기 큐에서 나와 그 다음 데이터를 전송하고 잠을 잔다. 

#### 전체범위 처리 vs 부분범위 처리

- 쿼리에 order by가 있어서, DB서버가 '모든' 데이터를 다 읽어 정렬을 마치고나서 클라이언트에게 데이터를 전송을 시작하는 것은 '전체범위' 처리이다.
- 만약 정렬 조건에 쓰인 컬럼이 선두인 인덱스가 있다면, 인덱스 내에서 정렬되어 있기 때문에 부분범위 처리가 가능하다.
- 하지만 인덱스가 없다면, 정렬을 다 마치고 일정량씩 데이터를 전송해야 하기 때문에 부분범위 처리가 불가능하다.

#### Array Size 전략은?
- 대량이라면 Array Size값을 크게 해야, Fetch Call 건수를 줄일 수 있다. 
- 앞쪽 일부 데이터만 Fetch하다가 멈추는 프로그램이라면, Array Size작게 설정해야 비효율을 줄일 수 있다.  
	- Array Size가 불필요하게 크면, 쓸데없이 많은 데이터를 읽어 전송해버릴 수 있기 때문이다.  

### 3.2.2 부분범위 처리 구현

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

#### OLTP 환경
- 부분범위 처리가 가능하려면 인덱스를 이용해 소트 연산을 생략할 수 있어야 한다.
- 부분범위 처리는 앞쪽 일부만 출력하고 멈출 수 있는가이다. 

#### n-Tier 아키텍처
- **n-Tier(웹 환경)** 에서는 사용자(브라우저)와 DB 사이에 **WAS(웹 서버)** 가 끼어 있습니다.

- 그래서 자원 독점이 불가합니다.
	- 사용자가 1페이지를 보고 2페이지를 누를지, 그냥 창을 닫고 커피 마시러 갈지 서버는 모릅니다. 
	- 만약 1페이지(10건)만 주고 "다음 요청을 기다리며 DB 연결을 계속 유지"하면, 다른 사용자들이 DB에 접속을 못 합니다.
	- 그래서 WAS는 1페이지 분량을 DB에서 가져오자마자 DB 커넥션을 풀(Pool)에 바로 돌려줘야 합니다. 
	- 커넥션을 돌려준다는 건 DB와의 통로를 끊는다는 뜻이고, 통로가 끊기면 DB 서버에 남아있던 데이터(커서)도 사라집니다.

- 결국, "나머지 데이터는 서버에 두고 조금씩 가져오자(Stateful)"는 전략이 웹에서는 안 통한다는 뜻입니다.


#### n-Tier 아키텍처에서 왜 "부분범위" 처리가 유효할까?
> n-Tier에서 부분범위 처리가 유효하다는 말은, **"클라이언트가 커서를 열어놓고 야금야금 가져온다"** 는 뜻이 아니라, **"DB 서버가 필요한 만큼만 읽고 최대한 빨리 작업을 멈춰서(Stop-N) 결과를 돌려주게 만든다"** 는 뜻입니다.

- 비록 결과 전체를 나눠서 전송(Fetch)하지는 못하더라도, 10건을 추출하는 과정만큼은 부분범위 처리 원리를 써야 하기 때문입니다.
	- 나쁜 예 (전체범위): 10건만 보여줄 건데, 인덱스가 없어서 100만 건을 다 읽고 정렬한 뒤 1~10번을 추출함. (사용자는 10초 대기)
	- 좋은 예 (부분범위 원리 활용): 인덱스를 타고 들어가서 딱 10건을 채우자마자 DB 작업을 멈춤. 그리고 그 10건만 WAS로 보낸 뒤 커넥션을 끊음. (사용자는 0.1초 대기)

- 그래서 **"부분범위 처리 원리를 이용한 페이징 처리"** 가 n-Tier 성능의 핵심이 되는 것입니다.
		- 전송 관점 : 커넥션을 빨리 반환해야 하므로 "한 번에 다(그 페이지 분량을) 보낸다."
		- 추출 관점 : 그 한 페이지 분량을 만들 때 "전체를 다 뒤지지 않고 부분범위 처리 원리로 중간에 멈춘다."

#### n-Tier에서 부분범위 처리를 '구현'하는 비결 (페이징 쿼리)
- 웹 환경에서 부분범위 처리가 유효하려면 "쿼리 자체가 멈출 수 있게" 짜야 합니다.
	- 첫 번째 요청 (1~10번)
		- 인덱스를 타고 10번째 로우(Row)를 만나는 순간 DB가 멈추게 WHERE ROWNUM <= 10 같은 조건을 줍니다. 
		- 결과만 주고 커넥션은 끊습니다.
 - 두 번째 요청 (11~20번)
		- 사용자가 2페이지를 누르면, 다시 새로운 커넥션을 잡고 인덱스를 타고 20번째 로우까지 간 다음 앞의 10개를 버리고 뒤의 10개만 취합니다.#

### 배치 I/O
> **배치 I/O(Batch I/O)** 는 쉽게 말해 데이터를 하나씩 감질나게 읽어오는 게 아니라, **"한 번에 왕창 묶어서(Batch) 효율적으로 읽어오는 방식"** 을 말합니다.

#### 부분범위 처리 vs 배치 I/O

| 구분 | 부분범위 처리 (OLTP) | 배치 I/O (Batch) |
|---|---|---|
| 목표 | 응답 속도 (빨리 첫 화면 보여주기) | 처리량 (전체 데이터를 빨리 처리하기) |
| 핵심 | 중간에 멈추는 것 (Stop-N) | 묶어서 한꺼번에 읽는 것 |
| 사용처 | 웹 게시판, 앱 조회 | 월말 결산, 대량 데이터 이관 |

- '부분범위 처리'나 'Fetch'는 보통 사용자가 화면에서 한 페이지씩 볼 때 쓰는 방식이라면? 
- 배치 I/O는 수만, 수백만 건의 데이터를 한꺼번에 처리해야 할 때 성능을 높이기 위해 사용합니다.
- 결론적으로 배치 I/O는 "디스크에 자꾸 왔다 갔다 하는 게 제일 느리니까, 갈 때 한 번에 많이 들고 오자"는 전략입니다.

#### 왜 배치 I/O가 필요할까?
마트에서 장을 본다고 생각해보세요.
- 일반 I/O : 사과 하나 집어서 계산대에 갖다 놓고, 다시 가서 배 하나 집어서 갖다 놓고... (매우 비효율적)
- 배치 I/O : 카트를 끌고 가서 사과, 배, 포도를 한꺼번에 담은 뒤 한 번에 계산대로 가져가는 것.

#### 배치관련 핵심 기능 3가지
1. 블록 단위가 아니라 '여러 블록'을 한 번에 (Multi-Block Read)
	- 오라클이 평소에 데이터를 읽을 때는 '데이터 블록(8KB)' 하나씩 읽습니다. 
	- 하지만 배치 작업(전체 테이블 스캔 등)을 할 때는 **"어차피 다 읽을 건데 한 번에 여러 개 가져오자!"** 라고 판단합니다.
		- Single Block Read : 한 입씩 냠냠 (인덱스로 하나씩 찾을 때)
		- Multi-Block Read : 한 번에 다섯 입씩 꿀꺽 (배치 I/O의 기본)

2. 테이블 Prefetch
	- 인덱스를 타고 테이블 데이터를 찾아갈 때, 오라클이 **"음, 곧 이 블록들도 필요하겠군?"** 이라고 미리 짐작해서 리드-어헤드(Read-ahead)하는 기능입니다.
	- 하나 읽고 나서 다음 거 찾는 게 아니라, 다음에 읽을 것으로 예상되는 블록들을 미리 메모리(Buffer Cache)에 한꺼번에 올려버립니다. 
	- 디스크 I/O 횟수를 획기적으로 줄여줍니다.

3. 배치 I/O (Oracle 12c~ 새로운 기능)
	- 최근 오라클 버전에서는 더 똑똑한 **'Batch Table Access By Index ROWID'** 라는 기능이 생겼습니다.
		- 기존 방식 : 인덱스에서 주소(ROWID)를 얻으면 바로 테이블로 달려가서 데이터를 가져옵니다. (왔다 갔다 반복)
		- 배치 방식 : 인덱스에서 주소를 여러 개 모읍니다. 주소들을 디스크에 저장된 순서대로 정렬한 뒤, 같은 근처에 있는 데이터들을 한 번에 묶어서 가져옵니다.


#### 배치 I/O와 정렬
> Batch Table Access By Index ROWID 기능이 작동한다고 해서 최종 결과가 정렬되는 것은 아니므로, order by를 반드시 명시해야 한다.

| 상황 | ORDER BY 사용 여부 | 결과 및 성능 |
|---|---|---|
| 정렬이 꼭 필요한 경우 | 무조건 사용 | 인덱스만 잘 타면 성능 저하 없음 |
| 인덱스 컬럼 정렬 시 | 무조건 사용 | 오라클이 알아서 Sort 연산을 생략함 (매우 빠름) |
| 정렬이 상관없는 경우 | 생략 가능 | DB가 가장 편한 순서대로 던져줌 (가장 빠름) |

1. Batch Table Access By Index ROWID의 정체
	- 이 기능은 **"성능 최적화"** 를 위한 내부적인 움직임일 뿐, **"결과물 정렬"** 을 보장하지 않습니다.
 	- 기존 방식 : 인덱스에서 찾은 주소(ROWID) 순서대로 하나씩 테이블에 가서 데이터를 가져옵니다. (인덱스 순서대로 데이터를 가져오니 결과적으로 정렬된 상태일 확률이 높음)
 	- 배치 방식 : 인덱스에서 주소를 여러 개 모은 뒤, "디스크에 저장된 물리적 위치" 순서로 주소를 재정렬해서 한꺼번에 데이터를 읽어옵니다.

	- 여기서 정렬하는 대상은 '데이터'가 아니라 **'데이터의 위치 주소(ROWID)'** 입니다. 
	- 디스크 헤드가 덜 움직이게 하려고 주소 순서대로 읽는 것이지, 사용자가 원하는 이름순이나 날짜순으로 정렬해주는 것이 아닙니다. 

	- 따라서 이 기능을 쓰면 오히려 인덱스로 유지되던 정렬 순서가 깨질 수도 있습니다.
	- Batch Table Access By Index ROWID는 오라클이 "야, 내가 디스크에서 데이터 좀 편하게 들고 올게!"라고 부리는 부리는 내부적인 요령일 뿐입니다. 
	- 사용자는 이 요령에 상관없이 결과가 정렬되길 원한다면 반드시 ORDER BY 명시를 해야 합니다.

2. ORDER BY를 써야 하는 이유 (정렬 보장)
	- 데이터베이스의 세계에는 **"ORDER BY가 없으면 정렬을 보장하지 않는다"** 라는 철칙이 있습니다.
 - 인덱스를 탔더라도 오라클 내부 알고리즘(배치 I/O 등)에 의해 결과 순서가 바뀔 수 있습니다.
 - 오늘은 인덱스를 타서 정렬된 것처럼 보여도, 내일 데이터가 많아져서 오라클이 "인덱스 말고 테이블 전체 스캔(Full Scan)이 빠르겠네?"라고 판단하면 정렬 순서는 완전히 뒤죽박죽이 됩니다.

3. "그럼 정렬하면 느려지잖아?" (부분범위 처리와의 관계)
	- 여기서 우리가 앞에서 배운 부분범위 처리가 다시 등장합니다.
 - 인덱스 컬럼으로 ORDER BY를 하면, 오라클은 "어? 어차피 인덱스가 이 순서대로 정렬되어 있네? 따로 정렬(Sort) 작업 안 해도 되겠다!"라고 판단합니다.
 - 실제 SORT 연산은 생략하면서, 사용자가 원하는 정렬 순서는 보장하고, 동시에 **부분범위 처리(Stop-N)** 까지 가능해집니다.



