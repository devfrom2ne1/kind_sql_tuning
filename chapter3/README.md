# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

### 3.1.2 인덱스 클러스터링 팩터

### 3.1.3 인덱스 손익분기점

### 3.1.4 인덱스 컬럼 추가

### 3.1.5 인덱스만 읽고 처리

### 3.1.6 인덱스 구조 테이블

### 3.1.7 클러스터 테이블



## 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리

### 3.2.2 부분범위 처리 구현

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리


## 3.3 인덱스 스캔 효율화

### 3.3.1 인덱스 탐색

### 3.3.2 인덱스 스캔 효율성

### 3.3.3 액세스 조건과 필터 조건

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

### 3.3.6 BETWEEN을 IN-List로 전환

### 3.3.7 Index Skip Scan 활용

### 3.3.8 IN 조건은 '='인가

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### 3.3.12 함수호출부 해소를 위한 인덱스 구성



## 3.4 인덱스 설계

### 3.4.1 인덱스 설계가 어려운 이유

### 3.4.2 가장 중요한 두 가지 선택 기준

### 3.4.3 스캔 효율성 이외의 판단 기준

### 3.4.4 공식을 초월한 전략적 설계

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

### 3.4.6 결합 인덱스 선택도

### 3.4.7 중복 인덱스 제거

### 3.4.8 인덱스 설계도 작성


