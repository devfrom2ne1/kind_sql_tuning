# 1. SQL 처리 과정과 I/O

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 vs 하드 파싱 

#### 메모리 공간
![img](https://github.com/devfrom2ne1/kind_sql_tuning/blob/main/images/SGA.gif)

1. SGA(System Global Area)
	- 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간

2. 라이브러리 캐시
	- SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 사용할 수 있게 캐싱해 두는 메모리 공간

#### 파싱 과정에서의 소프트파싱과 하드파싱
1) 사용자가 SQL문 전달
2) DBMS가 SQL 파싱
3) DBMS가 라이브러리 캐시에 존재하는지 확인
4) **소프트파싱**
	- 라이브러리 캐시에 SQL이 존재하면, 바로 실행
5) **하드파싱**
	- 라이브러리 캐시에 SQL이 존재하지 않으면, "최적화 -> 로우 소스 생성 -> 실행" 단계를 거침

#### 라이브러리 캐시가 필요한 이유
- 하드파싱은 CPU를 많이 사용하는 몇 안 되는 작업 중 하나이다.
- CPU를 사용하는 하드파싱 작업을 통해 생성한 내부 프로시저를 한 번만 사용하고 버린다면 비효율이 너무 크기 때문이다.
- 옵티마이저가 SQL을 최적화할 때 사용하는 정보
	- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
	- 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
	- 시스템 통계 : CPU속도, Single Block I/O, Multi Block I/O
	- 옵티마이저 관련 파라미터

### 1.2.2 바인드 변수의 중요성

#### 왜 SQL은 이름이 없을까?
- 일회성 또는 무효화된 SQL까지 저장하려면 공간도 많이 필요하고 속도도 느려지기 떄문이다.
- 그래서 SQL은 이름이 없이 텍스트 전체가 라이러리 캐시에 저장되어 재사용된다.
- 반면, 프로시저, 트리거 등은 생성할 때부터 이름이 있고, 컴파일한 상태로 딕셔너리에 영구적으로 저장된다.

#### 바인드변수가 필요한 이유는?
- 바인드변수가 없으면, input값이 달라질때마다 새로운 SQL문이 생성되고 하드파싱 과정을 거친다. 
- 하지만 바인드 변수를 사용하면, 하드파싱은 최초 1회만 일어나고, 캐싱된 SQL을 공유할 수 있게 된다. 