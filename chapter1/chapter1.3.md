# 1. SQL 처리 과정과 I/O

## 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유

디스크 I/O 때문이다. 

### 1.3.2 데이터베이스 저장 구조

#### 데이터를 저장하는 과정

![img](https://github.com/devfrom2ne1/kind_sql_tuning/blob/main/images/TableSpace.png)

1. 테이블스페이스 생성
    - 데이터 파일 : 디스크 상의 물리적인 OS 파일
    - 테이블스페이스 : 세그먼트를 담는 콘테이너, 여러 개의 데이터파일로 구성됨 

2. 세그먼트 생성
    - 세그먼트 : 테이블, 인덱스, 파티션, LOB 등의 오브젝트
    - 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합

3. 데이터블록에 저장
    - 데이터 블록 : 실제 데이터를 저장하는 공간

4. 데이터 부족해지면, 익스텐트 추가 할당

#### 오라클에서 세그먼트에 할당된 인스텐트 목록 조회하는 방법

```sql
select segment_type, tablespace_name, extent_id, file_id, block_id, blocks 
from dba_extents
where owner = USER
and segment_name = 'MY_SEGMENT'
order by extent_id;
```

### 1.3.3 블록 단위 I/O

DBMS는 `데이터 블록` 단위로 데이터를 읽고 쓴다. (파일단위X)
- 특정 레코드 하나만 읽고 싶어도, 해당 블록을 통째로 읽는 구조임

#### 오라클 데이터베이스 블록 사이즈를 확인하는 방법

```sql
-- 방법(1)
show parameter block_size

-- 방법(2)
select value from v$parameter where name = 'db_block_size';
```

### 1.3.4 시퀀셜 액세스 vs 랜덤 액세스

테이블 또는 인덱스블록을 액세스 하는 방법은 `시퀀셜 액세스` 와 `랜덤 액세스` 두 가지가 있음

1. 시퀀셜 액세스
    - 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식

2. 랜덤 액세스
    - 한 블록씩 접근하는 방법 

### 1.3.5 논리적 I/O vs 물리적 I/O

#### DB 버퍼캐시란

- 라이브러리 캐시 : SQL, 실행계획, 함수, 프로시저 등을 캐싱하는 '코드 캐시'
- DB버퍼 캐시 : 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 두는 '데이터 캐시'
    - 서버 프로세스와 데이터파일 사이에 있어서, 데이터 블록을 읽을 때 'DB 버퍼캐시'를 먼저 탐색함
    - 공유 메모리 영역이므로, 같은 블록을 읽는 다른 프로세스도 득을 본다. 

#### 논리적 I/O vs 물리적 I/O

- 논리적 I/O : SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O
    - 블록 읽기 요청
    - 메모리 I/O : 전기적신호, 빠름
    - 전기적 신호

- 물리적 I/O : 디스크에서 발생한 총 블록 I/O
    - 버퍼캐시 Miss 
        - SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스함
    - 디스크 I/O
    - 액서스 Arm : 물리적작용, 느림, 디스크 경합 심할때는 더 느림

#### 왜 논리적 I/O 인가?

- (논리적 I/O 횟수) = (DB 버퍼캐시에서 블록을 읽은 횟수)
- (물리적 I/O 횟수) = (DB 버퍼캐시에서 못찾아서 디스크에서 읽은 블록 I/O)
- 테이블에 insert, delete 하지 않은 이상, 같은 SQL이 읽는 블록수는 같다. 논리적 I/O는 불변
- 반면, 물리적 I/O는 실행할 때마다 달라짐

#### 버퍼캐시 히트율(BCHR)

- 버퍼캐시 효율을 측정하는데 전통적으로 많이 사용해온 지표이다. 

- 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율이다.
    - BCHR = ( (논리적 I/O - 물리적 I/O) / (논리적 I/O) ) * 100
    - 물리적 I/O = 논리적 I/O * (100 - BCHR)

- 온라인 트랜젝션 애플리케이션의 적정 BCHR은 99%이다. 
    - 논리적 I/O는 일정하므로, 물리적 I/O는 BCHR에 의해서 결정된다. 
    - SQL성능을 높이기 위해선 논리적 I/O 낮은 상태로 일정하게 만들어야 한다.

- 논리적 I/O를 줄이는 방법은?
    - SQL을 튜닝해서 읽는 총 블록 개수를 줄이면 된다. 

### 1.3.6 Single Block I/O vs Multiblock I/O

- 메모리 캐시에 적재되지 않은 데이터를 찾을 때, I/O Call을 통해 '디스크 -> DB버퍼캐시'로 적재하고 읽음
    - 버퍼캐시가 메모리 ?!

- 이때, I/O Call 을 하는 두 가지 방법이 있음
    - `Single Block I/O` : 적은 데이터 블록을 읽을 때, 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
    - `Multiblock I/O` : 많은 데이터 블록을 읽을 때, 같은 익스텐트의 인접한 블록을 한꺼번에 읽어서 캐시에 미리 적재하는 방식

### 1.3.7 Table Full Scan vs Index Range Scan 

- `Table Full Scan` : 테이블에 속한 블록 전체를 읽어서 데이터를 찾는 방식
- `Index Range Scan` : ROWID로 테이블 레코드를 찾아가는 방식
    - `랜덤 액세스` + `Single Block I/O`
    - 많은 데이터를 읽을 때는 불리함
    - 읽었던 블록을 반복해서 읽는 비효율이 있음

### 1.3.8 캐시탐색 메커니즘

#### 버퍼캐시 구조

DBMS는 버퍼캐시를 해시 구조로 관리함
- 버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 `버퍼 헤더`를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스 함

#### 메모리 공유자원에 대한 액세스 직렬화

직렬화 메커니즘이 필요한 이유

- 버퍼캐시는 SGA 구성요소이므로, 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원임
- 하나의 버퍼블록을 두 개 이상 프로세스가 '동시에' 접근하면 블록 정합성 문제가 생길 수 있음
- 이떄, 공유된 자원을 한 프로세스식 순차적으로 접근하도록 하는 것이 `직렬화 메커니즘` 이다.

래치란?
- 직렬화 메커니즘(줄서기)이 가능하도록 지원하는 메커니즘이 `래치(Latch)` 이다.
- 간단하게 설명하자면, 자물쇠를 열 수 있는 키가 있는 프로세스만이 체인으로 진입할 수 있게하는 것이다. 

버퍼 Lock
- 버퍼블록 자체에도 `버퍼 Lock` 이라는 직렬화 메커니즘이 존재한다. 
- 래치를 해제한 상태로 있는 도중에 후행 프로세스가 같은 블록에 접근할 수도 있는 문제를 방지하기 위해 버퍼 Lock이 필요하다. 

