# 1. SQL 처리 과정과 I/O

## 1.3 데이터 저장 구조 및 I/O 메커니즘

---

### 1.3.1 SQL이 느린 이유

디스크 I/O 때문이다. 

### 1.3.2 데이터베이스 저장 구조

#### 데이터를 저장하는 과정

1. 테이블스페이스 생성
- 데이터 파일 : 디스크 상의 물리적인 OS 파일
- 테이블스페이스 : 세그먼트를 담는 콘테이너, 여러 개의 데이터파일로 구성됨 

2. 세그먼트 생성
- 세그먼트 : 테이블, 인덱스, 파티션, LOB 등의 오브젝트
- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합

3. 데이터블록에 저장
- 데이터 블록 : 실제 데이터를 저장하는 공간

4. 데이터 부족해지면, 익스텐트 추가 할당

#### 오라클에서 세그먼트에 할당된 인스텐트 목록 조회하는 방법

```sql
select segment_type, tablespace_name, extent_id, file_id, block_id, blocks 
from dba_extents
where owner = USER
and segment_name = 'MY_SEGMENT'
order by extent_id;
```

### 1.3.3 블록 단위 I/O

DBMS는 `데이터 블록` 단위로 데이터를 읽고 쓴다. (파일단위X)
- 특정 레코드 하나만 읽고 싶어도, 해당 블록을 통째로 읽는 구조임

#### 오라클 데이터베이스 블록 사이즈를 확인하는 방법

```sql
-- 방법(1)
show parameter block_size

-- 방법(2)
select value from v$parameter where name = 'db_block_size';
```

### 1.3.4 시퀀셜 액세스 vs 랜덤 액세스

테이블 또는 인덱스블록을 액세스 하는 방법은 `시퀀셜 액세스` 와 `랜덤 액세스` 두 가지가 있음

1. 시퀀셜 액세스

논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식

2. 랜덤 액세스

한 블록씩 접근하는 방법 

### 1.3.5 논리적 I/O vs 물리적 I/O

#### DB 버퍼캐시란
#### 논리적 I/O vs 물리적 I/O
#### 왜 논리적 I/O 인가?
#### 버퍼캐시 히트율

### 1.3.6 Single Block I/O vs Multiblock I/O

메모리 캐시에 적재되지 않은 데이터를 찾을 때, I/O Call을 통해 '디스크 -> DB버퍼캐시'로 적재하고 읽음
이때, I/O Call 을 하는 두 가지 방법이 있음

- `Single Block I/O` : 적은 데이터 블록을 읽을 때, 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
- `Multiblock I/O` : 많은 데이터 블록을 읽을 때, 같은 익스텐트의 인접한 블록을 한꺼번에 읽어서 캐시에 미리 적재하는 방식

### 1.3.7 Table Full Scan vs Index Range Scan 

- `Table Full Scan` : 테이블에 속한 블록 전체를 읽어서 데이터를 찾는 방식
- `Index Range Scan` : ROWID로 테이블 레코드를 찾아가는 방식
    - `랜덤 액세스` + `Single Block I/O`
    - 많은 데이터를 읽을 때는 불리함
    - 읽었던 블록을 반복해서 읽는 비효율이 있음

### 1.3.8 캐시탐색 메커니즘

#### 버퍼캐시 구조

DBMS는 버퍼캐시를 해시 구조고 관리함
버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 `버퍼 헤더`를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스 함

#### 메모리 공유자원에 대한 액세스 직렬화

버퍼캐시는 SGA 구성요소이므로, 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원임
하나의 버퍼블록을 두 개 이상 프로세스가 '동시에' 접근하면 블록 정합성 문제가 생길 수 있음
이떄, 공유된 자원을 한 프로세스식 순차적으로 접근하도록 하는 것이 `직렬화 메커니즘` 이다.

이런 줄서기가 가능하도록 지원하는 메커니즘이 `래치(Latch)` 이다.
자물쇠를 열 수 있는 키가 있는 프로세스만이 체인으로 진입할 수 있기하는 것이다. 

버퍼블록 자체에도 `버퍼 Lock` 이라는 직렬화 메커니즘이 존재한다. 
래치를 해제한 상태로 있는 도중에 후행 프로세스가 같은 블록에 접근할 수도 있는 문제를 방지하기 위해 버퍼 Lock이 필요하다. 

